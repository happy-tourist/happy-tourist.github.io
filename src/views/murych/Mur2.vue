<template>
  <div><div class="grid-cols-1 grid gap-2.5 [&amp;_&gt;_*]:min-w-0 !gap-3.5"><h1 class="font-claude-response-title mt-1 text-text-100">Пересказ видео: Предварительная оптимизация - корень всех зол</h1>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">Введение и контекст</h2>
    <p class="font-claude-response-body whitespace-normal break-words">00:00:08 --- Проверяю звук — кажется, все работает. Записываю первую часть заново, потому что в прошлый раз при демонстрации примера с массивами случайно расшарил не тот экран. Там висел код пятнадцатилетней давности. Поэтому это будет короткое видео, посвященное только тому куску, который хочу переписать. По большому счёту, именно этот кусок будет самым полезным для тех, кто смотрит.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:01:00 --- Ещё раз подчеркну свое мнение насчёт фразы <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">"предварительная оптимизация — корень всех зол"</code>. Всем лучше забыть про эту фразу вообще навсегда и никогда не вспоминать. Исключение составляют только те люди, которые могут писать JavaScript на уровне <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">байт-кода</code> — все остальные благополучно вычёркивают её из своей жизни. Сейчас покажу, почему так думаю.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:01:32 --- Суть той фразы коротко заключается в том, что есть большущее количество людей, которые свою некомпетентность или своё нежелание разбираться в языке и сопутствующих технологиях прикрывают этой фразой. Дескать, это предварительные оптимизации, они, как мы все знаем, корень всех зол. Хочу продемонстрировать свой вопрос к этим людям — для меня-то ответ очевиден, а вы сами попробуйте на него ответить.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">Демонстрация базовой функции</h2>
    <p class="font-claude-response-body whitespace-normal break-words">00:02:09 --- Что такое те самые <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">предварительные оптимизации</code>? На экране сейчас короткая функция, называется <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">CopyArray</code>. Перепроверяю — да, вроде показывается.</p>
    <img :src="img1" width="300" alt="Image" loading="lazy">
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: На экране отображается код функции CopyArray с базовой реализацией — цикл for, пустой массив target, метод push для добавления элементов]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Задача этой функции — получить на вход один массив и выдать на выходе копию этого массива.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:02:33 --- В настоящий момент эта функция реализована следующим образом: есть цикл <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">for</code>, есть объявленный пустой массив <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">target</code>, в нём итерируем по длине массива, который передаётся на вход в функцию, и <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">пушами</code> загоняем туда все значения, после чего делаем <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">return</code> нашего массива и наслаждаемся тому, что у нас получилось всё правильно.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:03:04 --- В нижней консоли смотрю: сверху исходный массив, снизу второй массив. Теперь смотрим на эту функцию и задаём себе вопрос: что можем с этой функцией сделать с точки зрения того, чтобы этот код показался нам более оптимальным? Условно говоря, какие оптимизации к этой функции или вообще к этой логике можем применить?</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:03:30 --- Первое, что должно прийти на ум современному JavaScript-программисту в этом конкретном случае — да ну ёлки-мётелки, мы же в 2021 году, кто же так пишет! Вы же должны написать вот таким образом — использовать <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">rest-оператор</code> или как он правильно сейчас называется — и будете абсолютно правы. Давайте на секундочку представим — и это очень просто само по себе полезно — сейчас перепроверим, видим абсолютно эквивалентный результат.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:04:06 --- Представим, что находимся, например, в 2015 году, где никто о <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">рестах</code> или, тем более, о <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">мапах</code>, а тем более о рестах и подозревать не мог, или подозревал, но не мог пользоваться. Тогда все писали копирование массива в чём-то похожем на подобную функцию.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:04:24 --- Если сейчас посмотрим на эту функцию — какое количество улучшений к этой функции каждый из нас может предложить? Предлагаю поставить кому-нибудь на паузу, кому интересно, и просто прикинуть в своей голове, что здесь можно улучшить.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">Анализ и первые улучшения</h2>
    <p class="font-claude-response-body whitespace-normal break-words">00:04:43 --- Сделаем вид, что прошла эта пауза, и начнём рассуждать на тему того, что видим перед собой.</p>
    <img :src="img2" width="300" alt="Image" loading="lazy">
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Модифицированный код функции CopyArray с первыми двумя оптимизациями — выделена переменная arrayLength и показано прямое присваивание вместо push]</p>
    <p class="font-claude-response-body whitespace-normal break-words">А между тем, видим перед собой функцию, которая представляет собой просто ужас для интерпретатора, для <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Ignition JavaScript</code>. То есть эта функция выполняется — даже не знаю, как придумать эту функцию по-другому, чтобы она выполнялась ещё медленнее, чем она выполняется сейчас.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:05:16 --- Первое улучшение, которое может предложить человек: он обратит внимание, что у нас есть некоторый вызов в цикле, связанный с определением длины массива, который пришёл на вход, и, дескать, он постоянно вызывается в <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">for</code>, что является некоторым <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">оверхедом</code>. Отчасти это правда, но в большинстве случаев и <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Ignition</code>, и тот же самый <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Turbofan</code> это прекрасно умеют оптимизировать. Но тем не менее, более чем согласен с тем, что здесь было бы намного корректнее, намного правильнее написать что-нибудь такое.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:05:49 --- <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">arrayLength</code> — вот сюда вынесли нашу длину и теперь её засунули вот сюда. И даже здесь лучше написать не <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">let</code>, а <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">const</code>. Чудесно. Первое улучшение прошло.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:06:10 --- Следующее улучшение, которое мог бы предложить человек, рассуждающий, думающий немножко, понимающий, что происходит: он бы сказал, что здесь использование <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">push</code> является оверхедом совершенно ненужным. У нас есть наши <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">i</code>, которые итерируются в массиве, мы берём <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">source[i]</code> — давайте посмотрим, что у нас получилось.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:06:16 --- Заменяем на <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">target[i] = source[i]</code>. Всё тот же самый массив, прекрасно, всё работает так, как надо. Улучшение это? Улучшение. Вот что хорошо — для того чтобы было видно, что это является действительно улучшениями.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">Критическая оптимизация</h2>
    <p class="font-claude-response-body whitespace-normal break-words">00:06:49 --- Да, действительно улучшение. А что ещё здесь можно улучшить? Все улучшения, которые сделали сейчас перед этим — это всё улучшения, которые приведут к улучшению производительности, но эта производительность не будет улучшена кардинально.</p>
    <img :src="img3" width="300" alt="Image" loading="lazy">
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код, показывающий критическое изменение — инициализация массива с предварительно объявленной длиной через new Array(arrayLength)]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Кардинально или радикально эту производительность сможем улучшить вот такой простой штукой: когда подготовленный наш массив, в который собираемся копировать, не просто объявим, а ещё и объявим той длиной, которая будет абсолютно эквивалентна нашему стартовому массиву.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:07:25 --- На следующем примере покажу, насколько это сильно увеличит вашу производительность.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">Теоретическое обоснование</h2>
    <p class="font-claude-response-body whitespace-normal break-words">00:07:25 --- Вообще, когда задавали вопрос одному очень хорошему специалисту на тему того, каким образом следует оптимизировать свой JavaScript-код, он любил повторять две фразы.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:07:46 --- Первая фраза: если хотите, чтобы ваш JavaScript-код максимально оптимизировался так, как только это возможно, то постарайтесь писать этот код так, как будто бы пишете на C. И второе, что он тогда сказал: не бывает волшебников в голубом вертолёте, которые прилетят и ваш говнокод превратят в какой-то супер-оптимизированный код.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:08:12 --- Вы должны обладать <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">культурой написания кода</code>, иначе говоря, владеть той платформой, на базе которой пишете код, и понимать, как она работает. И когда объявляете массив, например, подобным литералом — да неважно как — вы просто определили пустой массив, то, начиная итерировать в цикле этот массив и присваивая ему значение, ставите <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">интерпретатор</code> в позицию, когда он не знает, какого объёма памяти нужно выделить пространство, в которое нужно поместить этот массив.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:08:45 --- Он вынужден каждый раз проводить тесты: не вывалились ли мы там за пределы <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">стэка</code>, условно говоря, куда можно теперь расширить этот массив, а не дай бог он попал перед этим в область памяти, которая является ограниченной. Условно — сейчас упрощаю немножко сам фактор работы, потому что специфика тут не так важна — условно говоря, он взял кусочек памяти, которого было достаточно для десяти элементов массива, а мы вдруг здесь взяли и добавили одиннадцатый элемент массива.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:09:17 --- Иначе говоря, <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">интерпретатор не может выстроить эффективного предположения</code> относительно того, что будет происходить с этим массивом дальше. И при каждом добавлении подобного рода элементов — как-то пушем ли или как-то вот подобного рода присваиванием — мы ставим интерпретатор в сложную позицию, он пытается из этой позиции выкрутиться, в результате чего добавляет громаднейшее количество разного рода проверок и интерпретации нашего кода для того, чтобы сделать так, чтобы этот код корректно выполнился и возможно выполнился быстрее.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:09:40 --- Но если интерпретатору с самого начала подсказываем, говорим, что наш массив будет вот такой-то длины, то на базе этого предположения интерпретатор может построить <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">эффективную стратегию оптимизации</code> нашего кода. И, как покажу сейчас чуть позже в следующем тесте, увидите, что это ускоряет вот эту функцию минимум раз в десять, сразу же, моментально.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">Дополнительная оптимизация с управлением памятью</h2>
    <p class="font-claude-response-body whitespace-normal break-words">00:10:12 --- Так, у нас есть вот такие оптимизации. Но если посмотрим на эту нашу функцию — что ещё можем сделать с этой функцией, чтобы сделать её ещё быстрее? Если у нас стоит задача именно сохранить саму по себе функцию. У этой функции есть один большой недостаток. А в чём заключается этот недостаток?</p>
    <img :src="img4" width="300" alt="Image" loading="lazy">
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Модифицированная структура кода, где массив target объявлен вне функции CopyArray и передаётся в неё как параметр]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Недостаток заключается в том, что каждый раз, когда запускаем эту нашу функцию, создаём массив, который потом возвращаем в этой функции.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:10:45 --- Каждый раз этот создаваемый массив у нас естественно заставляет выделить определённый объём памяти под его работу. Но поскольку возвращаем ссылку именно непосредственно из этой функции, и вот здесь себе эту ссылку сюда же присваиваем, то когда начинает работать <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">garbage collector</code> — это та штука, которая пытается помочь нам с работой с памятью — она на самом деле заставляет всех себе стрелять в ногу, как в данном конкретном случае.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:11:12 --- Кроме непосредственного самого массива памяти точно так же сохраняются и все <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">накладные расходы</code>, связанные с нашей вот этой вот функцией, в силу того, что ссылку, которую объявили, она находится у нас вот здесь. То есть, для того чтобы максимально эффективно с точки зрения распределения прочих ресурсов написать эту функцию, правильнее было бы вообще вынести вот эту нашу штуковину за пределы — вот мы, если <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">target</code> собираемся использовать где-то здесь у нас дальше, то перед определением нашей функции создаём наш массив <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">target</code> и потом его передаём внутрь нашей функции вот сюда вот, вот таким вот образом.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:12:10 --- И вот это получим, наверное, один из самых оптимальных вариантов в случае, если у нас мы должны итерировать, используя обязательно <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">for</code>, и крутиться внутри этого нашего цикла. Может быть, ещё есть какого-то рода более тонкие вещи, но эти принесут максимальный профит.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:12:40 --- Вот в данном случае опять спрашиваю: это <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">предварительные оптимизации</code>, которые попадают под фразу "предварительной оптимизации — корень всех зол", или это <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">знание той архитектуры</code>, с которой мы работаем?</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">Практическое тестирование производительности</h2>
    <p class="font-claude-response-body whitespace-normal break-words">00:12:40 --- Пока рассуждаем внутри своей башки на эту тему, хочу продемонстрировать то, как это влияет собственно говоря на производительность.</p>
    <img :src="img5" width="300" alt="Image" loading="lazy">
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код теста производительности на экране с вызовами performance.now(), циклом на 100,000 итераций, определением тестового массива, вычислением времени и выводом результатов в миллисекундах в консоль]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Здесь определяем массив как литерал, делаем наш тестовый массив, который будем копировать. <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">performance.now()</code> — результат объявим, сделаем сто тысяч итераций — то есть сто тысяч раз в результат добавим наш массив, это просто для демонстрации разницы. Берём копию массива от массива и передаём туда наш массив. Получаем финальное время, выводим.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:14:06 --- Чтобы да, всё есть. И теперь берём нашу функцию, называется <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">ArrayPerfs</code>. Запускаем, и вижу, что при данной реализации потребовалось нашей машине 190 миллисекунд.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:14:36 --- Лишний раз надо провести — самое главное при тестировании, первое, с чего нужно начинать: это код, который пытаетесь тестировать, прогнав через сотню раз один и тот же тест, вы должны получать <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">сопоставимые постоянно результаты</code>. Если у вас разброс в цифрах становится значительным относительно того, что меряете, относительно того, что выигрываете, значит нужно улучшать тест, потому что, иначе говоря, вы не понимаете, что меряете.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:15:13 --- В данном случае, в моём случае, разброс между 150 и 180 миллисекундами — он уже достаточно большой, но он сейчас продиктован тем, что одновременно и стримлю, и произвожу тест. Но для демонстрации того, что у нас происходит, сейчас будет этого достаточно, потому что разница будет в порядке.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Итого, видим, что сейчас эта функция — вот она наша, вот это наше копирование. Даже можем сейчас, ну правда, как раз продемонстрировать, что некоторые улучшения, которые можем применить, если они и влияют положительно на наш код, то это влияние будет крайне незначительным.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:15:38 --- Видим, что наши цифры приблизительно сопоставимы тем же цифрам, которые и были перед этим. Прекрасно. И теперь мы поняли, что у нас в районе 150–180 миллисекунд требуется на выполнение подобного рода итераций.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:15:59 --- И теперь приводим этот массив к тому состоянию, о котором говорил выше. Когда объявили здесь у нас нашу переменную, связанную с длиной входящего массива, объявили наш массив <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">target</code> как <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">new Array(arrayLength)</code> — то есть заранее предопределили его длину, здесь влепили наш <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">arrayLength</code> внутри этой итерации, здесь, естественно, никаких пушей, делаем прямое присваивание — вот так. Лишнюю скобочку убрали, здесь всё вернули, здесь всё.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:16:34 --- Запускаем тот же наш самый тест и наблюдаем сокращение почти во сколько получается — в два раза выполнения всего этого только объявлением одного массива. Потому что все остальные вещи — они положительно сказываются, но в рамках того, что сейчас измеряем, мы эти цифры не увидим, они там занимаются десятком миллисекунд, а не сотнями, как сейчас мы видим.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:17:00 --- И вот обратите внимание: сейчас, проведя подобного рода простую оптимизацию — то есть это даже не оптимизация, это просто <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">знание платформы</code>, как правильно с этим работать — объявив результирующий массив <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">targetArray</code> как массив с определённой длиной, потому что знаем точно, что и куда будем копировать, мы получили сокращение выполнения нашего кода почти — это сколько там было, 150, стало там 70 — это минимум в два раза улучшили выполнение нашего кода. В два раза простым правильным объявлением массива для работы со всем этим.</p></div></div>
  <div><div class="grid-cols-1 grid gap-2.5 [&amp;_&gt;_*]:min-w-0 !gap-3.5"><h1 class="font-claude-response-title mt-1 text-text-100">Пересказ видео: Предварительная оптимизация и знание платформы</h1>
    <hr class="border-border-300 my-2">
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:17:32</strong> --- Это <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">предварительная оптимизация</code>. Вот такие вещи некоторые люди, возможно, предпочтут прикрыть фразой, что это является предварительной оптимизацией. Но это не является предварительной оптимизацией, это является всего лишь знанием элементарных базовых основ той платформы, с которой вы работаете. И вы должны знать эти базовые основы этой платформы.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:17:53</strong> --- Понятно же, что для того, чтобы уже добить всех окончательно, опять же по поводу знания базовых основ этой платформы, есть один очень забавный феномен, связанный со специалистами, со мной в том числе. Не в том смысле, что я специалист, а в том смысле, что феномен со мной связан. Как мы говорили выше, сейчас, в 2021 году, правильным копированием массива была бы вот такая вот конструкция.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:18:21</strong> --- Сейчас увидим, насколько это производительнее всего того, что выше. Запустил.</p>
    <img :src="img6" width="300" alt="Image" loading="lazy">
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Запуск файла array.js через инструмент perf - терминал/консоль показывает результаты тестирования производительности с тремя измерениями времени выполнения для разных способов копирования массива]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Видим, что теперь выполнение этого кода занимает почти <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">30 миллисекунд</code>. Против <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">70 миллисекунд</code>, когда пишем цикл for, и против <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">170 миллисекунд</code>, когда неправильно объявили массив.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:18:49</strong> --- И это еще я сейчас не отключал никаких оптимизаций, потому что в данном случае и <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Ignition</code> и <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">TurboFan</code> еще очень сильно помогает и спасает предыдущий код от проблем с производительностью. И опять же просто используя современную конструкцию, которая выполняет ту же самую работу, но сделанную зная архитектуру нашей среды, в которой мы работаем, мы знаем что мы эту конструкцию можем таким образом использовать, мы улучшили производительность нашего кода еще в два раза. Это является предварительной оптимизацией или не является?</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:19:23</strong> --- Так вот, по поводу феномена. Дело все в том, что когда появились <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">REST</code>, <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">SPREAD</code> и прочие параметры в V8, они появились там халтурно. Уж не знаю, с чем это связано, поскольку все вещи, которые сейчас связаны с V8 и с Google Chrome, в первую очередь это маркетинг, а уже во вторую очередь это прогрессивные улучшения. Это вот когда они тогда появились, вышли и были объявлены как зарелизенные, это были вещи, которые работали крайне неоптимизированно, это в лучшем случае, и это были вещи, которые были написаны на самом же JavaScript.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:19:49</strong> --- Например, вот те же, вся функциональщина, которая в свое время появилась вместе с всей функциональной методой, связанной с обработкой массива, типа <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">MapReduce</code> и так далее, они все появились в V8 в реализации на том же самом JavaScript, то есть иными словами вы могли с тем же самым успехом написать точно такой же метод на какой-нибудь своей собственной функции, получить абсолютно то же самое, но им было важно в то время заявить о том, что они уже поддерживают эти функциональные методы.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:20:19</strong> --- Они их выкатили, естественно вляпались в то, что специалисты, которые занимаются производительностью, тут же поняли, что простая итерация того же самого массива в цикле в JavaScript оказывается значительно быстрее, чем использование MapReduce или чего-то. И правила не использовать ни <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Map</code>, ни <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Reduce</code>, ни <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">ForEach</code>, прочие функциональные методы, какие там у них еще были, фильтры, <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">IndexOf</code>, закрепилось в голове, что их использовать не нужно, потому что это создает лишний overhead, который приводит фактически де-факто к тому, что проще использовать напрямую итерируемый массив.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:21:15</strong> --- Очень многие люди по привычке до сих пор, замисшись в том времени и в силу обстоятельств не могут себя отсовершенствовать, откорректировать, продолжают писать итерируемые вот подобного рода вещи, обрабатывая массивы. Хотя сейчас уже эти методы переписаны и оптимизированы, как мы видим на примере того же, по-моему REST, это же правильно называется, или Spread, я дислексик, я все время все названия забываю, это либо REST, либо Spread, я не помню, как это называется, вот, мы видим, что на самом деле все изменилось исключительно в положительную сторону. Так вот опять я задаю вопрос, это <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">предварительная оптимизация</code> или это <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">знание платформы</code>, с которой мы работаем?</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:22:11</strong> --- Когда Дональд Кнут впервые ее употребил, он ее употребил в <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">1972 году</code>, когда люди писали на языках, которые большинству сейчас людей недоступны как вообще для понимания, в силу того, что они привыкли работать уже со средствами намного более развитыми, чем в то время, и второе, прозвучала эта фраза в контексте, который для очень многих людей сейчас вообще совершенно непонятен.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:22:39</strong> --- Она прозвучала в контексте выяснения, что лучше пожертвовать частично производительностью своего кода, но написать свой код не используя операторов <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">безусловного перехода</code> типа <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">GOTO</code>, которых вы сейчас в JavaScript не увидите, хотя под капотом они есть, я могу показать, как их использовать. Или, используя операторы GoTo, операторы прямых переходов, выиграв производительность и потеряв во времени с этой производительностью, но потерять там, условно говоря, читаемость кода.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:23:05</strong> --- На самом деле речь шла не столько о читаемости кода, сколько о возможности в будущем <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">компилятора</code>, который использует разного рода эвристики для оптимизации нашего кода, <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">предсказывать</code>, эффективно предсказывать, что собирается делать наш код для того, чтобы его эффективно оптимизировать. Как показала дальнейшая практика и дальнейшее развитие с 1972 года, Дональд Кнут был абсолютно прав в своем выводе о том, что мы должны писать <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">предсказуемый код</code>.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:23:32</strong> --- Мы не должны тратить громаднейшее количество времени на оптимизации, характерные для какого-то частного, конкретного случая, но должны тратить свое время на совершенствование своего кода в сторону его предсказуемости. Такой предсказуемости, которой бы компилятор или интерпретатор, который использует наш код в работе, мог бы предсказать и эффективно оптимизировать и использовать. Дональд Кнут не говорил о том, что не нужно использовать спреды.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:23:59</strong> --- Он не говорил о том, что не нужно знать о том, что длину массива нужно объявлять заранее. И не говорил о том, что написав подобным вот образом, мы прекрасно справились со своей задачей. Мы не прекрасно справились, мы продемонстрировали свою полную <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">некомпетентность</code> в решении этой задачи.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:24:19</strong> --- Именно поэтому всем нужно забыть про существование этой фразы, и каждый раз, написав свой код, да нет, даже код не будем этого касаться, читать постоянно литературу от разных умных людей, начиная от Дональда Кнута, там, от классиков наших, этого, как его, господи боже мой, как же мне трудно жить.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:25:05</strong> --- <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Dextro</code>, например, <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Huara</code>, это все классика программирования. Люди, которые описали вам в книжках максимально подробно в абстрактном языке все алгоритмы, которые вы должны использовать, и заканчивая чтением, например, того же самого <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">блога v8</code>, движка v8, в котором они рассказывают о том, что они сейчас нового сделали внутри своего движка, должны быть в курсе, что теперь можно использовать, а что не использовать, и перечитывая периодически любую документацию или спецификацию, связанную с вашим языком, для того, чтобы не писать вот эти дальше такие глупости, а писать <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">высокоэффективный код</code>.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:25:42</strong> --- Да, в общем-то на этом все. Хотел я, а ну как в качестве бонуса продемонстрировать как в современном JavaScript можно написать <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">goto</code> в прямом смысле этого слова.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:25:59</strong> --- Демонстрируем. Напишем вот так, это назовем goto, CSS должны знать что это такое, это мы объявили блоки.</p>
    <img :src="img7" width="300" alt="Image" loading="lazy">
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Редактор кода JavaScript показывает синтаксис создания блоков с метками - использование фигурных скобок {} для объявления блоков, каждый блок имеет свой идентификатор/метку]</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:26:14</strong> --- Каждый такой блок является определенной областью видимости для конструкции типа там <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">let</code> и <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">const</code>, но волнует нас сейчас не это, волнует нас сейчас то, что каждый такой блок может иметь <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">метку</code>, например блок 1, блок 2. Так, еще раз проверить, у меня вообще показывается то что я хочу? Да, то что я хочу. Блок 2 и блок 3. Это три блока, которые у нас имеют метки.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Теперь есть такой оператор <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Break</code>, который позволяет прервать текущую область видимости и выйти за ее пределы, там где она закрывается. Но кроме этого, оператор Break позволяет использовать метки, которые мы показываем в области видимости, и конкретно указать, за какую область видимости мы хотим вывалиться. Для того, чтобы это было нагляднее, мы напишем вот так, в консоли Log, правильно?</p>
    <img :src="img8" width="300" alt="Image" loading="lazy">
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код с добавленными операторами console.log в каждом блоке - три блока (блок1, блок2, блок3), каждый содержит свой console.log]</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:27:35</strong> --- Да. Здесь будет у нас блок 3, а теперь смотрим, смотрите. Вот это у нас блок 2, вот это у нас блок 1.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:27:48</strong> --- Теперь если мы запустим это мы увидим блок 3, блок 2, блок 1, дан, прекрасно, да, все верно, вот тут не вовремя.</p>
    <img :src="img9" width="300" alt="Image" loading="lazy">
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Вывод консоли показывает результаты выполнения - отображается "блок3 блок2 блок1 дан", подтверждая что все три блока выполнились по порядку]</p>
    <p class="font-claude-response-body whitespace-normal break-words">А теперь смотрите какая штука, если мы напишем вот так вот и например вот блок 2, мы здесь напишем блок 2.</p>
    <img :src="img10" width="300" alt="Image" loading="lazy">
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код модифицирован - добавлен оператор "break блок2" внутри блока 2, визуальное выделение этой строки]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Обратите внимание что у нас произойдет: блок 3, блок 1, дан.</p>
    <img :src="img11" width="300" alt="Image" loading="lazy">
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Вывод консоли с модифицированным кодом - отображается "блок3 блок1 дан", вывод блока 2 отсутствует, демонстрируя что break блок2 вызвал переход мимо console.log этого блока]</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:28:19</strong> --- А самое интересное это не это, самое интересное как это выглядит на уровне ассемблерного. Это у нас называется goto, goto.js, а ну да конечно, секунду.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:28:49</strong> --- Так, это мы сделаем функцией есть, здесь мы сделаем, подготовить к оптимизации, готовить к оптимизации.</p>
    <img :src="img12" width="300" alt="Image" loading="lazy">
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код оборачивается в функцию для подготовки к оптимизации - показан процесс конвертации блочного кода в функциональную структуру]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Так, во-первых, первый раз его вызвать, подготовить к оптимизации goto, второй раз его вызвать.</p>
    <img :src="img13" width="300" alt="Image" loading="lazy">
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Множественные вызовы функции - визуально показаны четыре отдельных вызова функции "подготовить к оптимизации", объяснение что множественный вызов запускает JIT-компиляцию и оптимизацию]</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:29:32</strong> --- Теперь мы сделаем option next call goto третий раз. Мы его вызовем и, и четвертый раз мы его вызываем есть, и должно быть вот наш код.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:30:06</strong> --- И вот сейчас покажу конкретно, он сейчас же же оптимизирован, вырезан вообще, дурилка картонная. Здесь мы сделаем up, здесь мы напишем вот так, и если up эквивалентно true, то тогда сделать break.</p>
    <img :src="img14" width="300" alt="Image" loading="lazy">
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код с условными операторами - добавлен параметр "up" в функцию, условие if (up === true) then break, множественные проверки с разными значениями true/false в разных местах: первое - true, второе - false, третье - true, четвертое - true, пятое - false]</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:30:34</strong> --- Вот так, здесь мы пишем, чтобы его не запутать, здесь мы пишем true, тут мы пишем false, тут мы пишем true, тут мы пишем опять true, а тут мы пишем опять false, вот теперь весь код. Видите, компилятор насколько умный.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Вывод скомпилированного/ассемблерного кода - результаты анализа компилятора, ключевая находка: компилятор обнаружил мертвый код, показана демонстрация кода который никогда не может быть выполнен, действие компилятора - просто не скомпилировал его, выбросил из работы, демонстрирует интеллект компилятора при оптимизации]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Он обнаружил что вот этот тот код мертвый, он не может быть никогда выполнен, он его просто даже не компилировал, выкинул из своей из нашей работы.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:31:00</strong> --- И теперь у нас сейчас наша goto, наш брейк находится, сначала здесь. У нас же патрух, да, у нас же патрух. Да правильно, здесь мы сделали наш консоль лог, выполнили его, проконтролировали что это мы проконтролировали, вот и вот он, да, он уже даже отсюда перекинул нас.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Ассемблерный код с отслеживанием console.log - визуальное отслеживание вызова console.log в ассемблере, показан поток выполнения: console.log выполнен, проконтролирован/проверен в ассемблере, показана точная точка перехода]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Как бы это понагляднее показать. У нас же внутри.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:34:09</strong> --- Для упрощения мы уберем всю вот эту фигацию с консоль влог, она нам не мешала.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код с удаленными операторами console.log - упрощение демонстрации, удалено "все это дело с console.log"]</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:34:56</strong> --- А ведь даже смотрите еще как интереснее компилятор все сделал, переделал этот код мой.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Оптимизированный ассемблерный код - ключевая находка "посмотрите как интересно компилятор все сделал", действие компилятора: переписал/трансформировал код, показанная оптимизация: не просто вставил безусловный переход, компилятор обнаружил что когда переменная App (переданная в функцию) установлена в true, действие - немедленно передать выполнение кода к завершению блока 2, прямой переход к "break-блок2"]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Он не просто в данном случае вставил безусловный переход, он обнаружил для себя, что в случае, когда переменная App, которую мы передаем в функцию, установлена в true, то нужно сразу же переводить выполнение кода к завершению блочный блок, блока 2, break-блок 2.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:35:28</strong> --- Вот. И вот что происходит.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Детальный ассемблер с аннотациями - код на ассемблере, контролирует входящую переменную со значением true, если true: оптимизировано без дополнительных вещей, немедленно переходит к ветке выполнения связанной с загрузкой функции Console.Log2, демонстрация того как можно симулировать условные и безусловные переходы в JavaScript]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Вот этот код на языке ассемблера же происходит, он здесь его контролирует входящую переменную со значением true. И если это true, он сразу же это оптимизировал без всяких дополнительных вещей, он меня тут же перекинул в выполнение ветки кода, связанной с загрузкой и выполнением функции Console.Log2. Вот таким вот образом можно сейчас симулировать в JavaScript условный и безусловный переход. На самом деле же можно было просто убрать это условие, получился бы безусловный переход к блоку 2, вот сюда вот.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:36:01</strong> --- Это блок 3, да, вот здесь надо было бы вот так написать, вот здесь консоли, консоль лог блог 2 1, вот так вот написать, так 3, вот и тогда бы 3 у нас не показалось и блок 2 перешел вот сюда, кстати мы сейчас можем это и увидеть правильно. Правильно, у нас там true true goto, лишние только мы сейчас уберем, вот сейчас у нас консоль лог.</p>
    <img :src="img15" width="300" alt="Image" loading="lazy">
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Упрощенный код без условий - удаление условной логики, состояние кода: остается только "true true" в функции goto, удаление ненужных частей]</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:36:32</strong> --- Блок 3 выведена не будет эти блок 1, потому что блок 2 вот он у нас, брейк блок 2 это означает перейти к выполнению вот на закрытие блока 2 нашей метки, которую мы обозначили.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Вывод консоли из упрощенного кода - визуальный вывод "блок3 ... блок1 дан", подтверждение: блок2 не отображен, объяснение: прямой переход от блока 3 к блоку 1, пропуск содержимого блока 2]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Это по поводу того, как можно сейчас, если очень хочется, делать операторы GOTO.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:36:52</strong> --- Но делать этого не стоит по причине того, что для сначала для <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">интерпретатора</code> или <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">джета</code>, который смотрит ваш код, оптимизация вашего кода становится достаточно сложной задачей, потому что очень тяжело бывает выстроить логичную цепочку предположений или составить такой код, который бы впоследствии позволил ему сделать такое предложение, это чтобы этот код оптимизировать.</p>
    <p class="font-claude-response-body whitespace-normal break-words">И вторая большая проблема со всеми <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">условными</code> и <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">безусловными переходами</code> заключается в том, что для наших микропроцессоров, с которыми мы сейчас работаем, подобного рода переходы очень часто приводят к перезагрузке его внутреннего <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">кэша</code>, кэша выполнения операции.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:37:33</strong> --- На самом деле процессор не выполняет инструкцию за инструкцией, так раньше когда-то процессоры работали. Современные процессоры, когда столкнулись с тем, что частоту они эффективно уже улучшать дальше пока не могут, они начали внедрять большое количество разных техник, связанных с кэшами, с дополнительными ядрами и прочим.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Так вот, когда работает процессор на уровне ассемблера, на уровне своего процессорного кода, вот он, вот здесь вот, то, что вот здесь вот циферками вот это вот обозначено, на самом деле процессор загружает в свой кэш вот такой целыми блоками уже код, заранее пытается его понять, интерпретировать и выполнить.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:38:07</strong> --- Но каждый раз, когда он может сталкиваться с условными или безусловными переходами, это может приводить к тому, что вся его логика загруженного в <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">кэш-кода</code> заранее, предположения о том, как он может выполняться, полностью можно выбросить ее в унитаз, потому что произошел резкий переход в другую часть кода, который сейчас в кэше не находится. И тем самым сбросить кэш, и тем самым сделать выполнение нашего кода уже на уровне процессора еще медленнее.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:38:26</strong> --- Поэтому, именно поэтому, ту проблему, которую в 1972 году пытался в своей статье обозначить Дональд Кнут, в современном мире уже проблемы не является, для всех является очевидным, что код мы должны писать для компилятора <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">предсказуемо</code>, для процессора предсказуемо, максимально стараясь избегать подобного рода переходов.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><strong>00:38:56</strong> --- Так, все, за сим я прощаюсь. Большущее всем спасибо.</p></div></div>
</template>
<script setup lang="ts">
import img1 from '@/assets/mur/mur2/1.PNG';
import img2 from '@/assets/mur/mur2/2.PNG';
import img3 from '@/assets/mur/mur2/3.PNG';
import img4 from '@/assets/mur/mur2/4.PNG';
import img5 from '@/assets/mur/mur2/5.PNG';
import img6 from '@/assets/mur/mur2/6.PNG';
import img7 from '@/assets/mur/mur2/7.PNG';
import img8 from '@/assets/mur/mur2/8.PNG';
import img9 from '@/assets/mur/mur2/9.PNG';
import img10 from '@/assets/mur/mur2/10.PNG';
import img11 from '@/assets/mur/mur2/11.PNG';
import img12 from '@/assets/mur/mur2/12.PNG';
import img13 from '@/assets/mur/mur2/13.PNG';
import img14 from '@/assets/mur/mur2/14.PNG';
import img15 from '@/assets/mur/mur2/15.PNG';
</script>