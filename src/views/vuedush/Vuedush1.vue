<template>
  <div><div class="grid-cols-1 grid gap-2.5 [&amp;_&gt;_*]:min-w-0 !gap-3.5"><h1 class="font-claude-response-title mt-1 text-text-100">Пересказ: Основы Vue.js — Реактивность</h1>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:00:17 --- Философия преподавания и вводные слова</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Перед тем как выложить это видео, хочу поделиться несколькими вступительными словами, и лучше всего за меня скажет твит, который сегодня выложил Traversy Media. Это человек, известный огромным количеством курсов в англоязычном пространстве. Он жаловался на то, что у нас постоянно обновляется React Router, постоянно обновляется Tailwind — был Tailwind конфиг, и вот нет Tailwind конфига. Как можно так жить, когда прошло всего 18 дней, а твои туториалы уже устарели?</p>
    <p class="font-claude-response-body whitespace-normal break-words">И пока я ходил, вел лекции у студентов, Мэтт Покок, автор прекрасного курса по TypeScript, написал еще лучший ответ, который идеально ложится в нашу концепцию. Его ответ звучит так: учителя, которые не обновляют свои курсы, наносят больше урона, чем авторы библиотек, которые обновляют свои библиотеки.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Именно поэтому я формулирую свой принцип жизни так: <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">преподавать Vue надо так, чтобы я не смог продать вам курс по React такого же уровня</code>. Мы будем фокусироваться на трех элементах.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Первое — <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">концепции</code>. То есть не просто «напишите здесь вот это заклинание», а как это организовано и, главное, какие цели преследовали, когда так делали.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Второе — <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">нюансы</code>. Буду честен, они очень часто отражены в документации и даже прям выделены словами «обратите внимание». Но так сложилось, что люди, когда не имеют практического опыта с каким-то аспектом, как-то пропускают это сквозь пальцы. Когда конкретный живой человек, живая говорящая голова сказала «смотрите, вот здесь вот так больно», это запоминается лучше.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Третий аспект — мы будем базироваться на <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">актуальных вещах</code>. Курс был записан во времена Vue 3.4, он актуализирован до Vue 3.5, поэтому местами вы увидите, как на мне магически изменяется одежда и прочие монтажные склейки.</p>
    <p class="font-claude-response-body whitespace-normal break-words">И тут четвертый аспект, который я не назвал — это <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">упрощение</code>. Сейчас в процессе рассказов те, кто знает Vue, могут хохотеть и дописать: «на самом деле он сказал, что вот так не делается, но так можно делать вот здесь». Да, я знаю, но поскольку моя задача вначале дать минимум магии, а потом сказать «смотрите, а вот здесь в компонентах у нас происходит вот такая магия, и вот такая магия», именно поэтому я буду давать это постепенно.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Так что те, кто в комментариях будет рассказывать, что я про что-то не рассказал, вполне возможно делают вашим коллегам хуже, нарушая именно <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">образовательную структуру повествования</code>. Это не означает, что если я сказал что-то, в чем кардинально не прав — давайте не путать умолчание и ошибку — что на нее не надо указывать. Конечно, моя цель делать контент, который не содержит фактических ошибок, который выживет во времена Vue 3.6, 3.7, 3.8 и хотелось бы 4.0.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Мне бы хотелось курс, по итогам которого вы, приходя с Vue на другой фреймворк, сказали бы: «так я же это уже знаю, это же та же концепция». Или когда Vue выпустит нововведение VaporMode, которое они делают, вы скажете: «окей, но это же ничего почти не меняет в наших концепциях». Поэтому начинаем разговоры с высокоуровневых понятий, высокоуровневых концепций и двигаемся ниже.</p>
    <hr class="border-border-300 my-2">
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:04:56 --- Что такое реактивность и концепция состояния</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Как мы упоминали, одной из двух основных концепций, которые лежат в основе современного Vue.js, является <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">реактивность</code>. На самом деле сейчас под термином реактивность понимают два понятия, и мы постараемся сегодня разобрать оба из них.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Но перед тем как разбираться, что же за зверь реактивность, давайте поговорим в принципе об идеологии, которая сейчас лежит в основе, наверное, любой библиотеки, любого фреймворка, который вы найдете на рынке. Возможно, только на ум приходит htmx и ему подобные, которые не придерживаются их. А именно — у нас есть понятие <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">состояния</code>.</p>
    <p class="font-claude-response-body whitespace-normal break-words"><code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Состояние</code> — это данные вашего приложения, которые изменяются с течением времени.</p>
    <img :src="img1" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Диаграмма показывает центральную концепцию - в верхней части экрана находится блок СОСТОЯНИЕ, от которого стрелка направлена вниз к блоку ПОЛЬЗОВАТЕЛЬСКИЙ ИНТЕРФЕЙС (UI)]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Примером может быть список TODO — у пользователя массив строк, мы его добавляем, удаляем. Это состояние. Светофор — текущий сигнал, который горит, изменяется с течением времени, значит это состояние светофора. Для сравнения, металл, из которого сделан светофор, ну очевидно, скорее всего в нашем приложении, в нашей модели не изменяется с течением времени, так что нам скорее всего не интересен. Если вы, конечно, не делаете игрушку, где у вас есть разные светофоры с разными типами, тогда это вполне может быть состоянием светофора.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Так вот, состояние — это данные. Данные пользователь не видит, он видит интерфейс. И вот фактически ключевой идеей, которая лежит в основе React, Vue, Angular, является вот эта простая стрелочка: <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">состояние определяет то, что пользователь видит на экране</code>.</p>
    <p class="font-claude-response-body whitespace-normal break-words">При этом обратите внимание: одни и те же тудушки мы можем отрисовать по-разному. Мы можем отрисовать их простым списком, а можем отрисовать их в виде канбан-доски, где можно тягать между колонками. Таким образом, за отображение того, как наше состояние будет выглядеть, отвечает наш код.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Из этой простой схемы самое главное то, что во главе угла стоит именно <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">состояние</code>, а UI — подчиненный элемент. И этот элемент, тем не менее, как-то же он должен изменять состояние, а как он изменяет?</p>
    <img :src="img2" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: На диаграмме появляется обратная стрелка от UI к СОСТОЯНИЮ, формируя цикл. Показаны промежуточные элементы: кнопки → события → изменение состояния → код рендерит UI]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Да, у нас появляется обратная стрелочка. За счет чего она? Да все очень просто. Пользователь, к примеру, кликает по кнопочкам, кнопочки генерируют <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">события</code>, события изменяют <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">состояние</code>, состояние перерисовывается благодаря коду в UI. И вот такой уроборос и является ключевой концепцией современного фронтенда во многом.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Конечно, здесь у нас есть очень серьезное упрощение. Почему? Причиной изменения состояния совершенно не всегда является UI. Вспомним опять тот же светофор — он меняется сам по себе, с течением времени. Поэтому, к примеру, у нас просто состояние может изменяться по <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">таймерам</code>, у нас могут прилетать данные по <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">веб-сокетам</code>, которые изменяют состояние и так далее.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Но суть с точки зрения пользовательского интерфейса остается одна и та же. Мы изменяем состояние, и <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">ответственность нашего кода</code>, когда состояние изменилось — <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">перерисовать интерфейс</code>.</p>
    <hr class="border-border-300 my-2">
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:09:00 --- Практический пример: простой счетчик</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Давайте же посмотрим на вот эту концепцию на реальном примере. Пример максимально простой. У нас есть счетчик, который мы при клике увеличиваем на единичку. Когда мы накликали больше 10, кнопочка становится красной. Когда счетчик меньше 10, она соответственно обычного цвета.</p>
    <img :src="img3" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: На экране показан код - переменная counter, функция renderCounter и обработчики событий. Визуально видна кнопка с текстом "Счетчик: X", которая меняет цвет на красный при значении больше 10]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Как реализовано? Обратите внимание, даже здесь, в таком примитивном примере, мы видим те концепции состояния, которые я озвучил. Переменная <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">counter</code> — это наше состояние. Функция <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">renderCounter</code> — это функция, которая отображает наше состояние на экран. Обработчики событий: когда произошел клик, увеличь counter на единичку, обнови counter. Увеличь counter на 0, обнови counter. Но отрисуй состояние.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Как я уже и сказал, состояние может меняться не только по пользовательским событиям, поэтому мы добавим простенький интервал, который увеличивает счетчик, ну допустим каждую секунду.</p>
    <hr class="border-border-300 my-2">
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:09:23 --- Проблема забытого вызова renderCounter</h2>
    <img :src="img4" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: В коде добавлен setInterval, который увеличивает counter каждую секунду, но на экране ничего не происходит - счетчик визуально не обновляется]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Добавили, сохранили, ничего не происходит. Но если я кликну, я вдруг увижу, что счетчик меняется как-то не по единичке, правда? Почему это происходит? Ну, это же очевидно — я забыл сказать, что надо перерисовать наше состояние, поскольку оно обновилось.</p>
    <img :src="img5" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код исправлен - внутри setInterval после увеличения counter добавлен вызов renderCounter(), и теперь счетчик визуально обновляется каждую секунду]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Добавляю вызов функции renderCounter, и мы видим, что счетчик пошел.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Но представьте себе, что у вас не приложение из одной переменной и состояние не из одной переменной, а огромный сложный реальный проект. <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Какова вероятность, что где-то вы измените состояние и забудете позвать перерисовщик?</code> Будем откровенны — на 100%.</p>
    <hr class="border-border-300 my-2">
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:10:49 --- Определение реактивности</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Как мы можем это решить, то есть какую задачу мы решаем? Мы хотим получить возможность <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">реагировать на изменение состояния</code>.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Вот <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">реактивность</code> в школярском, но тем не менее достаточном для нас определении — это <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">способность системы реагировать на изменение своего состояния</code>.</p>
    <hr class="border-border-300 my-2">
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:11:05 --- Решение через функцию useCounter (подход как в React)</h2>
    <p class="font-claude-response-body whitespace-normal break-words">К примеру, мы можем сделать функцию <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">useCounter</code>, в которой что мы сделаем? Мы спрячем саму переменную counter сюда, и теперь мы возьмем и вернем объект, в котором будут две функции: <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">getCounter</code>, которая возвращает состояние переменной counter, и <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">setCounter</code>, очевидно, которая присваивает в counter новое значение.</p>
    <img :src="img6" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: На экране показан рефакторинг кода - создана функция useCounter, внутри которой спрятана переменная counter, и возвращается объект с методами getCounter и setCounter]</p>
    <p class="font-claude-response-body whitespace-normal break-words">И чтобы мы никогда не забывали обновить counter, мы сделаем вызов функции renderCounter прямо вот здесь в <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">setCounter</code>. Уберем вот этот вызов.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Теперь мне нужно для того, чтобы пользоваться моим counter'ом, создать состояние counter'а: counterState равно useCounter. Но я ленивый, мне лень писать через точечку. Я вот здесь сразу выполню деструктуризацию, разберу его на две переменные: <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">getCounter</code> и <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">setCounter</code>.</p>
    <p class="font-claude-response-body whitespace-normal break-words">И теперь в моем коде я пишу setCounter getCounter плюс один. Очевидно, что такая же логика поедет в обработчик интервала. А здесь будет еще проще логика: setCounter 0.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Обратите внимание, чего мы добились. Теперь у меня просто <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">физически нет возможности изменить состояние counter, забыв обновить его на экране</code>.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Если вы писали до этого на React'е, то вот этот код, не считая квадратных скобочек и мелких дополнительных нюансов, очень уж должен напомнить вам Hook <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">useState</code>.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Это подход, который решил применить у себя React. То есть, грубо говоря, мы прячем состояние внутри определенных функций и предоставляем инструменты для работы с этим состоянием снаружи. Таким образом, мы не можем никак изменить его в обход.</p>
    <hr class="border-border-300 my-2">
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:13:35 --- Подход Vue: getter и setter (Vue 2)</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Окей. Но Vue говорит: как-то это не очень по-джаваскриптерски, плюс мало ли, а вдруг вот здесь у меня будет не переменная, а объект, а объекты можно мутировать. Слушайте, а давайте мы вспомним, что с незапамятных времен в JavaScript есть возможность определять <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">getter</code> и <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">setter</code> на объектах.</p>
    <img :src="img7" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: На экране показан новый подход - создан объект counterState с внутренней переменной _value и методами getValue и setValue]</p>
    <p class="font-claude-response-body whitespace-normal break-words">И поэтому я создам объект <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">counterState</code>, в котором у меня будет два метода: <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">getValue</code> и <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">setValue</code>. Очевидно, что value мне надо где-то хранить, поэтому я буду хранить его в переменной подчеркивание value, к примеру. GetValue, очевидно, будет ее как раз-таки просто возвращать, а setValue вообще-то будет ее присваивать: this._value равно newValue.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Хорошо. Теперь, очевидно, мне снова понадобится функция renderCounter. Опишу ее ниже, чтобы она видела объект counterState, которая будет выглядеть, очевидно, как counterButton.textContent равно "Счетчик:" и counterState.value.</p>
    <p class="font-claude-response-body whitespace-normal break-words">И в setter'е буду всегда вызывать функцию renderCounter. Теперь мне надо будет не забыть, поскольку у меня теперь объект, здесь написать counterState.value, очевидно же. И вместо всех этих причандалов setCounter мне надо написать counterState.value плюс равно 1.</p>
    <img :src="img8" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Обновленный код показывает более естественный JavaScript-синтаксис с прямым доступом к свойству counterState.value вместо вызовов функций]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Согласитесь, стало выглядеть красивее. Здесь counterState.value равно 0. Ну и здесь, очевидно, counterState.value плюс равно 1.</p>
    <p class="font-claude-response-body whitespace-normal break-words">И, как видите, оно опять заработало. Давайте вернем функцию renderCounter, логику с classList.toggle для красной кнопки. Доходим до 10. Все снова работает. Прекрасно.</p>
    <p class="font-claude-response-body whitespace-normal break-words">Мы только что построили реактивность так, как она работала во <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Vue.js 2</code>. Мы добавляли getter и setter, Vue магическим образом добавлял их к объектам.</p>
    <hr class="border-border-300 my-2">
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:16:20 --- Проблема getter/setter и решение через Proxy</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Это имеет определенные недостатки. Ключевым недостатком является то, что если у объекта counterState появится какое-нибудь новое поле newValue, оно <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">не будет реактивным</code>, мы не будем его отслеживать, потому что у нас нет getters и setters для него. Нам надо озаботиться установкой getters и setters для каждого нового поля.</p>
    <img :src="img9" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: На экране показана проблема - если добавить counterState.newValue = 123, это поле не будет реактивным, так как для него не определены getter и setter]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Но с ECMAScript 2015 есть метод и получше. Этот метод называется использование <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Proxy</code>. Proxy оборачивает наш объект в дополнительную обертку, которая позволяет <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">перехватывать обращение к произвольным полям объекта</code>, к которому обращаются.</p>
    <img :src="img10" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Визуальная схема показывает концепцию Proxy - объект оборачивается в Proxy-обертку, которая перехватывает любые обращения к полям и позволяет выполнять логику на get и set]</p>
    <p class="font-claude-response-body whitespace-normal break-words">То есть вы обращаетесь к counterState.value, и мы можем выполнить определенную логику на get и set. Это решение было доступно с ECMAScript 2015 и именно оно используется в современном Vue.js 3 для реализации реактивности, что позволяет отслеживать изменения любых полей объекта автоматически, без необходимости заранее определять для них getters и setters.</p></div></div>
  <div><div class="grid-cols-1 grid gap-2.5 [&amp;_&gt;_*]:min-w-0 !gap-3.5"><h1 class="font-claude-response-title mt-1 text-text-100">Основы Vue — Реактивность (Продолжение)</h1>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:17:17 — Введение и переход к встроенной реактивности Vue</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Переписать этот пример с использованием вызова newProxy оставляю на ваше усмотрение, потому что это позволит закрепить, как работает <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">реактивность</code> во Vue 3, а она именно работает на proxy. Теперь же бессовестно импортирую функцию <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">ref</code> из Vue. Функция ref в Vue делает абсолютно то же самое, что делалось в собственной реализации раньше — создает объект с полем <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">value</code>, и в соответствии с этим полем value происходят все изменения.</p>
    <img :src="img11" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код с импортом ref из Vue и создание counterState через ref]</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:17:50 — Первая демонстрация работы ref</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Если сейчас вызвать renderCounter, то видим, что вывелся счетчик 5. Прекрасно!</p>
    <img :src="img12" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Браузер показывает результат работы счетчика со значением "5" на странице]</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:18:15 — Отслеживание изменений через watch</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Но как отслеживать изменения? Для этого есть функция <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">watch</code> во Vue. Обращаю внимание: если ref будем в дальнейшем при разработке постоянно использовать, то watch — это на самом деле такой фулл последней надежды. Детально разберем почему позже, но сейчас для демонстрации реактивности это хорошо подходит. Можем сказать, что следи за объектом counterState, и когда он изменился, вызови функцию renderCounter.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:18:47 — Автоматическое обновление счетчика</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Раз — и счетчик опять пошел!</p>
    <img :src="img13" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Демонстрация автоматически обновляющегося счетчика после добавления watch]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Но можем еще лучше. Опять же, во Vue есть, кроме функции watch, функция <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">watchEffect</code>. Обратите внимание, что в функцию watchEffect передается только сама функция renderCounter.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:19:12 — Особенности использования watchEffect</h2>
    <img :src="img14" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">Можно написать вот так, но как показала практика, хоть это и смотрится в разы эстетичнее, у людей это почему-то вызывает небольшое подвисание. Когда используется еще одна ненужная обертка в виде анонимной функции, людям это понятнее. Подождите, а как Vue понимает, когда нужно вызывать renderCounter? Обратите внимание, что можем отслеживать обращение и на <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">set</code>, и на <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">get</code>, и вызывать перерисовку.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:19:49 — Механизм работы watchEffect</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Что делает Vue? Vue видит: эй, у меня передали в watchEffect функцию, и Vue сразу же вызывает эту функцию. Функция внутри обращается к полю value у counterState. Перехватываем это благодаря тому, что можем перехватывать <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">get</code>. Ага! Это значит, что эта функция зависит от counterState, раз к нему обращаемся. Поэтому когда поле counterState будет изменяться, буду автоматически вызывать перерисовку. Круто, правда?</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:20:08 — Введение вычислимых свойств</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Но можем еще лучше! Сейчас обратим внимание, что есть вот такая особенная функция isCounterToBig, которая проверяет на то, что — и фактически она возвращает логику, зависящую от состояния.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:20:49 — Концепция computed</h2>
    <p class="font-claude-response-body whitespace-normal break-words">То есть что-то, что можем посчитать только исходя из текущего состояния. Видите, она не принимает аргументов и обращается к состоянию. Это так называемое <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">вычислимое свойство</code>. Вычислимое, потому что это то, что можно посчитать.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:21:07 — Реализация computed во Vue</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Оно во Vue вызывается с помощью функции <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">computed</code>. Можно написать, что const isCounterTooBig — это computed, вычислимое свойство от counterState.value больше 10. И теперь isCounterTooBig и counterState ведут себя одинаково — это объектики, у которых есть поле value внутри, и поэтому вот здесь надо написать isCounterTooBig.value, чтобы это работало.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:21:43 — Проверка работы computed</h2>
    <p class="font-claude-response-body whitespace-normal break-words">После этого, давайте проверим все: watchEffect, render, открываем консоль, смотрим на ошибки. MyIdentifier isCounterTooBig has already been declared — потому что надо, конечно же, удалить старую функцию, и оно опять пошло.</p>
    <img :src="img15" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Консоль браузера показывает вызовы функции renderCounter на каждый тик таймера с сообщениями console.log. При быстрых кликах вызовы происходят чаще]</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:22:29 — Наблюдение за вызовами функции</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Скажете: ну, а в чем же соль? Ну добавили какую-то одну переменную, зачем? Следите за руками! Вот здесь вставляю вызов функции console.log в renderCounter, который будет говорить о том, что функция вызвана. Открываю консольку. Ну и вот видим, абсолютно ожидаемо наша функция вызывается каждый раз, на каждый тик. Если буду щелкать быстрее, будет вызываться быстрее.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:22:56 — Разделение на две функции</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Теперь же разобью функцию renderCounter на две. Одну оставлю, и она будет называться renderCounter, а другая будет называться, допустим, updateCounterColor. Она будет делать ровно изменение цвета. И скажу то же самое: watchEffect updateCounterColor. Ничего не поменялось, казалось бы.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:23:23 — Демонстрация избирательной перерисовки</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Но смотрите за руками! Добавляю сюда console.log Color. Открываю HTML.</p>
    <img :src="img16" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Консоль показывает сообщение "HTML.Color" вызвалось один раз, затем "Color не вызывается" при последующих обновлениях счетчика, демонстрируя избирательную перерисовку]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Смотрите: вызвалась HTML.Color. И Color не вызывается. Упс! Вызвалась и больше не вызывается. Представьте себе, что вот здесь, точнее вот здесь, вместо просто изменения цвета была бы какая-нибудь тяжелая логика обновления HTML. Только что волшебным способом получили возможность не перерисовывать кусок HTML!</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:24:05 — Объяснение механизма зависимостей</h2>
    <p class="font-claude-response-body whitespace-normal break-words">А за счет чего? Потому что Vue видит абсолютно по той же логике updateCounterColor. Он говорит: ага, значит наша функция updateCounterColor зависит от чего? Она зависит от обертки, в которой лежит true/false, которая isCounterTooBig, которая, в свою очередь, посчитана от объекта, в котором лежит value, value 6.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:24:38 — Визуализация цепочки зависимостей</h2>
    <img :src="img17" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Диаграмма на экране показывает цепочку зависимостей со стрелками: counterState (со значением 6) указывает стрелкой на функцию renderCounter. Также counterState указывает на вычислимое свойство isCounterTooBig (значение false), которое в свою очередь указывает на функцию updateCounterColor]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Дальше происходит цепочка: неважно каким образом изменяем counterState, Vue говорит — эй, так от изменения состояния counterState зависит функция renderCounter, он ее радостно вызывает. И зависит вот этот computed, вычислимое свойство. И оно проверяет: так, value все еще меньше 10, здесь как было false, так и осталось.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:25:23 — Условная перерисовка</h2>
    <p class="font-claude-response-body whitespace-normal break-words">И раз здесь как было false, так и осталось — так чего буду вызывать функцию updateCounterColor, если у меня значение не поменялось? Когда же здесь значение станет 11, здесь значение изменится с false на true, и Vue такой: о, значение поменялось!</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:25:43 — Точечное изменение HTML</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Пришло время вызывать функцию updateCounterColor. Обратите внимание, как, не написав ничего особенного — то есть единственное, что сделали: показали, что смотри, вот это свойство isCounterTooBig зависит от состояния — получили возможность <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">точечного изменения HTML</code>. И вот это второе определение реактивности, о котором говорил.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:26:13 — Определение fine-grained reactivity</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Это то, что часто называют <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">fine-grained reactivity</code>. Не существует хорошего перевода этого на русский язык, потому что если перейдем дословно, это называется мелкозерновая реактивность. Но предпочитаю назвать ее <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">точечной</code> или <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">высокоточной реактивностью</code>. То есть можем перерисовывать элементы странички и элементы HTML только тогда, когда данные, которые они отображают, изменились.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:26:42 — Пример точечной реактивности</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Как в нашем случае изменяем цвет кнопочки только тогда, когда изменилось <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">вычислимое свойство</code> isCounterTooBig от состояния. Учимся применять правильные термины. Окей, сразу те, кто уже знакомы с Vue: а как же reactive и прочее? До этого дойдем, пока задача поговорить о реактивности.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:27:15 — Важная особенность proxy</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Ложечка дегтя во всем этом. Важно понимать, что <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">proxy оборачивает объект</code>. Что это означает? Представим себе, что в counterState изначально лежит — вот есть const InitialState, в котором лежит объект с полем counter. То есть раньше там лежало число, а теперь лежит объект. Оборачиваю его в ref, теперь в поле value лежит объект с полем counter. Не забываю, надеюсь, нигде обновить.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:28:09 — Ошибка с undefined</h2>
    <img :src="img18" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: На экране выводится "счетчик undefined" после изменения структуры данных на вложенный объект]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Так, вот, видите: выводится счетчик undefined. И почему? И здесь, соответственно, точно так же не забываю обновить: value.counter, value.counter, value.counter — все, счетчик пошел. И isCounterTooBig точно так же. Интересно, почему у меня red? Потому что здесь, конечно же, просто .value — это чушь написал. Вот, получаем искомый результат.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:28:56 — Структура вложенных объектов</h2>
    <p class="font-claude-response-body whitespace-normal break-words">То есть, казалось бы, что поменялось? Если раньше оборачивал число, то теперь в value лежит ссылочка на вот этот объект.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:29:11 — Магия автоматической обертки</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Ну окей, здесь срабатывает магия, что во Vue, когда у proxy берем поле, которое тоже является объектом, оно тоже оборачивает его в proxy. Как это можно проверить?</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:29:36 — Проверка через консоль</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Да очень просто! Смотрите, вот выведу console.log InitialState и выведу counterState.value. И откроем консольку. Давайте еще раз обновим. И говорят, что полезно слово консоль.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:30:05 — Разница между объектами</h2>
    <img :src="img19" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Консоль браузера показывает два выведенных объекта: первый отображается как простой объект "Counter", второй — с надписью "Reactive" (через DevTools), что указывает на обертку Proxy]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Обратите внимание: одно вывелось как просто Counter — это наш объектик вот этот. А второе вывелось надписью Reactive. Это используются там DevTools. Если посмотрим внимательно, то это на самом деле Proxy. То есть оно обернуло внутреннее значение поля counterState.value в Proxy.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:30:33 — Проблема обхода proxy</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Чем это чревато? А это чревато ровно одной вещью. Смотрите, если вот здесь обновлю counter не в counterState, а в InitialState, то у меня сломается реактивность.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:31:04 — Демонстрация потери реактивности</h2>
    <img :src="img20" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Счетчик перестает автоматически обновляться на экране, ведет себя так, как будто забыли добавить обновление в setInterval — значение застыло и не меняется]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Смотрите, она начинает вести себя, как будто раньше было, когда забывал в setInterval поставить обновление. Почему так происходит? Потому что внутри объекта InitialState обновляем вот этот объект. Но Vue ничего не знает об этом. Это сделали в обход proxy. Сохранилась прямая ссылочка на вот этот внутренний объект, а не на обертку proxy. И поэтому Vue не смогло отследить это.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:31:28 — Решение проблемы реактивности</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Это единственный, наверное, специфический большой способ потерять реактивность, что было болью во времена Vue 2, но теперь не является такой болью во времена Vue 3. То есть, грубо говоря, в реальности, если хотим соблюдать реактивность, то должны как можно раньше обернуть сущность в <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">REF</code> и таким образом добиться результата.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:31:54 — Рекомендации по практике</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Для тех, кто хочет максимально закрепить, рекомендую повторить этот пример с нуля самостоятельно. Нет, исходников не дам, чтобы не копипастили. То есть написать страничку, на которой есть две кнопки, которые обновляются, и потом написать это на getter и setter, написать это на new proxy. Это будет достаточно легко. И после этого подключить watchEffects, computed и получить желаемый эффект, и таким образом понять, почему нам важно...</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:32:20 — Проблема поля .value</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Что неприятного? Давайте уберу, чтобы хранили все-таки в чистом виде число, чтобы не было лишнего поля — то есть везде убираю .counter, потому что состояние у нас вроде бы просто число. А по итогу вынуждены везде тягать за собой вот эта точка <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">.value</code>.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:32:57 — Неизбежность .value</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Да, это так, и ничего с этим в общем виде сделать нельзя. Почему? Потому что <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">proxy могут оборачивать только объекты</code>. Увидим, как Vue немножечко хитрит в шаблонах для того, чтобы облегчить нашу участь с этим.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:33:19 — История Reactivity Transform</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Но в общем и целом действительно везде в коде явно пишем точка value. Те, кто, как говорится, алды помнят — раньше существовал так называемое предложение <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Reactivity Transform</code>, которое должно было волшебным способом преобразовывать код, дописывая там, где надо, точечку value. Но от этого отказались, потому что сильно много магии — это тоже плохо.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:33:46 — Итоговые определения</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Вот перед вами реактивность. Теперь знаете, что <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">реактивность</code> — это способность системы реагировать на изменения данных, в нашем случае это просто обновляя интерфейс пользователя. А <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">fine-grained reactivity</code> — опять же, на русский не существует устоявшегося перевода, перевожу как точечная или высокоточная реактивность — это способность перерисовывать только те элементы интерфейса, данные для которых обновились.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:34:20 — Сравнение с React</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Это то, что, к примеру, React не умеет из коробки — для этого там надо танцевать с бубном вокруг мемоизации, и там просто перерисовывается весь компонент. А Vue, благодаря магии proxy, благодаря тому, что он может отслеживать не только сеттеры, но и геттеры, обеспечивает нам волшебным, дешевым образом.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:34:45 — Дополнительные материалы</h2>
    <p class="font-claude-response-body whitespace-normal break-words">Традиционно в описании под видео будут ссылки на разделы документации Vue, которые рекомендую прочитать после того, как просмотрели видео, где в принципе рассказано плюс-минус то же самое другими словами.</p>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">00:35:02 — Анонс следующей темы</h2>
    <p class="font-claude-response-body whitespace-normal break-words">А на этом на сегодня все! В следующий раз поговорим о втором столпе Vue, а именно о декларативности и что подразумеваем, когда говорим о декларативном доме. Или, на самом деле, корректнее, конечно же, использовать термин, как это говорит Vue — декларативный HTML.</p></div></div>
</template>
<script setup lang="ts">
import img1 from '@/assets/vuedush/vuedush1/1.PNG';
import img2 from '@/assets/vuedush/vuedush1/2.PNG';
import img3 from '@/assets/vuedush/vuedush1/3.PNG';
import img4 from '@/assets/vuedush/vuedush1/4.PNG';
import img5 from '@/assets/vuedush/vuedush1/5.PNG';
import img6 from '@/assets/vuedush/vuedush1/6.PNG';
import img7 from '@/assets/vuedush/vuedush1/7.PNG';
import img8 from '@/assets/vuedush/vuedush1/8.PNG';
import img9 from '@/assets/vuedush/vuedush1/9.PNG';
import img10 from '@/assets/vuedush/vuedush1/10.PNG';
import img11 from '@/assets/vuedush/vuedush1/11.PNG';
import img12 from '@/assets/vuedush/vuedush1/12.PNG';
import img13 from '@/assets/vuedush/vuedush1/13.PNG';
import img14 from '@/assets/vuedush/vuedush1/14.PNG';
import img15 from '@/assets/vuedush/vuedush1/15.PNG';
import img16 from '@/assets/vuedush/vuedush1/16.PNG';
import img17 from '@/assets/vuedush/vuedush1/17.PNG';
import img18 from '@/assets/vuedush/vuedush1/18.PNG';
import img19 from '@/assets/vuedush/vuedush1/19.PNG';
import img20 from '@/assets/vuedush/vuedush1/20.PNG';
</script>