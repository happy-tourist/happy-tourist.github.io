<template>
  <div><div class="grid-cols-1 grid gap-2.5 [&amp;_&gt;_*]:min-w-0 !gap-3.5"><h1 class="font-claude-response-title mt-1 text-text-100">Основы Vue -- Реактивность</h1>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">Пересказ видеолекции</h2>
    <p class="font-claude-response-body whitespace-normal break-words">00:00:17 --- Перед тем как выложить это видео, хочу поделиться вступительными мыслями, и лучше всего о них скажет твит, который сегодня выложил Траверси-Медиа. Это человек, известный огромным количеством курсов в англоязычном пространстве. И пока я ходил и вел лекции у студентов, господин Мэтт Покок, автор прекрасного курса по TypeScript, написал еще лучший ответ, который идеально ложится в нашу концепцию. Он звучит так: учителя, которые не обновляют свои курсы, наносят больше урона, чем авторы библиотек, которые обновляют свои библиотеки. В твите жаловались на то, что постоянно обновляется React Router, постоянно обновляется Tailwind — был Tailwind конфиг и нет Tailwind конфига, и как можно так жить, когда прошло 18 дней, а твои туториалы уже устарели.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:01:06 --- Именно поэтому я формулирую свой принцип жизни так: <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">преподавать Vue надо так, чтобы я не смог продать вам курс по React такого же уровня</code>. У нас будет много остановок на более теоретических вещах, и мы будем фокусироваться на трех элементах. Первое — <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">концепции</code>: не просто «напишите здесь вот это заклинание», а как это организовано и, главное, какие цели преследовали, когда так делали. Второе — <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">нюансы</code>, которые, буду честен, очень часто отражены в документации и даже выделены словами «обратите внимание», но люди без практического опыта как-то пропускают это сквозь пальцы. Когда конкретный живой человек говорит «смотрите, вот здесь вот так больно», это запоминается лучше. Третий аспект — мы будем стараться базироваться на <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">актуальных вещах</code>. Курс был записан во времена Vue 3.4, он актуализирован до Vue 3.5, поэтому местами вы увидите, как на мне магически изменяется одежда и прочие монтажные склейки.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:02:38 --- Третий аспект, который я не назвал — это на самом деле <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">упрощение</code>. Сейчас в процессе рассказов те, кто знает Vue, могут хохотеть и дописать: «Вот, на самом деле он сказал, что вот так не делается, но так можно делать вот здесь». Да, я знаю, но поскольку моя задача вначале дать минимум магии, а потом сказать: «Смотрите, а вот здесь в компонентах у нас происходит вот такая магия, и вот такая магия, и вот такая» — именно поэтому я буду давать это постепенно. Те, кто в комментариях будут рассказывать, что я про что-то не рассказал, вполне возможно делаете вашим коллегам хуже, нарушая именно образовательную структуру повествования. Это ни в коем случае не означает, что если я сказал что-то, в чем кардинально не прав, на это не надо указывать — давайте не путать умолчание и ошибку. Конечно, моя цель делать контент, который не содержит фактических ошибок, который выживет во времена Vue 3.6, 3.7, 3.8 и, хотелось бы, 4.0.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:04:24 --- Мне бы хотелось курс, по итогам которого вы, приходя с Vue на Svelte, сказали бы: «Так я же это уже знаю, это же та же концепция». Или когда Vue выпустит нововведение VaporMode, вы скажете: «Окей, но это же ничего почти не меняет в наших концепциях». Поэтому начинаем разговоры с высокоуровневых элементов, высокоуровневых понятий, концепций и двигаемся ниже.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:04:56 --- Как мы и упоминали, одной из двух основных концепций, которые лежат в основе современного Vue.js, является <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">реактивность</code>. На самом деле сейчас под термином реактивность понимают два понятия, и мы постараемся сегодня разобрать оба из них. Но перед тем как разбираться, что же за зверь реактивность, давайте поговорим в принципе об идеологии, которая сейчас лежит в основе любой библиотеки, любого фреймворка, который вы найдете на рынке. Возможно, только на ум приходит htmx и ему подобные, которые не придерживаются их. А именно — у нас есть понятие <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">состояния</code>. Состояние — это <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">данные вашего приложения, которые изменяются с течением времени</code>.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:05:50 --- Примером может быть список TODO: список задач пользователя, массив строк, который мы добавляем и удаляем — это состояние. Светофор: текущий сигнал, который горит, изменяется с течением времени — значит, это состояние светофора. Для сравнения: металл, из которого сделан светофор, очевидно, скорее всего в нашем приложении, в нашей модели не изменяется с течением времени, так что нам скорее всего не интересен. Если вы, конечно, не делаете игрушку, где у вас есть разные светофоры с разными типами — тогда это вполне может быть состоянием светофора. Так вот, <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">состояние — это данные</code>. Данные пользователь не видит, он видит интерфейс. И вот фактически <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">ключевой идеей</code>, которая лежит в основе React, Vue, Angular, является вот эта простая стрелочка: <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">состояние определяет то, что пользователь видит на экране</code>.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:06:51 --- При этом обратите внимание: одни и те же задачи мы можем отрисовать по-разному. Мы можем отрисовать их простым списком, а можем отрисовать их в виде канбан-доски, где можно тягать между колонками. Таким образом, за отображение того, как наше состояние будет выглядеть, отвечает наш код. Из этой простой схемы самое главное то, что <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">во главе угла стоит именно состояние, а UI — подчиненный элемент</code>. И этот элемент, тем не менее, как-то же должен изменять состояние, а как он изменяет?</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:07:37 --- У нас появляется обратная стрелочка. Все очень просто: пользователь, к примеру, кликает по кнопочкам, кнопочки генерируют события, события изменяют состояние, состояние перерисовывается благодаря коду в UI. И вот такой <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">уроборос является ключевой концепцией современного фронтенда</code> во многом. Конечно, здесь у нас есть очень серьезное упрощение. Почему? Причиной изменения состояния совершенно не всегда является UI. Вспомним опять тот же светофор — он меняется сам по себе, с течением времени. Поэтому, к примеру, у нас просто состояние может изменяться по таймерам, у нас могут прилетать данные по веб-сокетам, которые изменяют состояние, и так далее. Но суть с точки зрения пользовательского интерфейса остается одна и та же: <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">мы изменяем состояние, и ответственность нашего кода — когда состояние изменилось, перерисовать интерфейс</code>.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:09:00 --- Давайте же посмотрим на эту концепцию на реальном примере. Пример максимально простой: у нас есть счетчик, который мы при клике увеличиваем на единичку. Когда мы накликали больше 10, кнопочка становится красной. Когда счетчик меньше 10, она соответственно обычного цвета.</p>
    <img :src="img1" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код с переменной counter, функцией renderCounter и обработчиками событий]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Обратите внимание: даже здесь, в таком примитивном примере, мы видим те концепции состояния, которые я озвучил. Переменная <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">counter</code> — это наше состояние. Функция <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">renderCounter</code> — это функция, которая отображает наше состояние на экран. Обработчики событий: когда произошел клик, увеличь counter на единичку, обнови counter.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:09:23 --- Как я уже и сказал, состояние может меняться не только по пользовательским событиям, поэтому мы добавим простенький интервал, который увеличивает счетчик, ну, допустим, каждую секунду.</p>
    <img :src="img2" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Добавление setInterval в код, который увеличивает counter каждую секунду]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Добавили, сохранили — ничего не происходит. Но если я кликну, я вдруг увижу, что счетчик меняется как-то не по единичке, правда? Почему это происходит? Ну, это же очевидно: я забыл сказать, что надо перерисовать наше состояние, поскольку оно обновилось.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:09:50 --- Добавляю вызов функции <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">renderCounter</code>, и мы видим, что счетчик пошел.</p>
    <img :src="img3" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Исправленный код с вызовом renderCounter() внутри setInterval]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Но представьте себе, что у вас не приложение из одной переменной, и состояние не из одной переменной, а огромный сложный реальный проект. Какова вероятность, что где-то вы измените состояние и забудете позвать перерисовщик? Будем откровенны — 100%.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:10:19 --- Как мы можем это решить? То есть какую задачу мы решаем? <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Мы хотим получить возможность реагировать на изменение состояния</code>. Вот <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">реактивность</code> в школярском, но тем не менее достаточном для нас определении — это <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">способность системы реагировать на изменение своего состояния</code>.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:11:05 --- К примеру, мы можем сделать функцию <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">useCounter</code>, в которой что мы сделаем? Мы спрячем саму переменную counter сюда, и теперь мы возьмем и вернем объект, в котором будут две функции: <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">getCounter</code>, которая возвращает состояние переменной counter, и <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">setCounter</code>, очевидно, которая присваивает в counter новое значение.</p>
    <img :src="img4" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код функции useCounter с переменной counter внутри, возвращающей объект с getCounter и setCounter]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:11:50 --- И чтобы мы никогда не забывали обновить counter, мы сделаем вызов функции <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">renderCounter</code> прямо вот здесь, внутри <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">setCounter</code>.</p>
    <img :src="img5" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: setCounter с автоматическим вызовом renderCounter() внутри]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Уберем вот этот вызов из обработчиков. Теперь мне нужно, для того чтобы пользоваться моим counter'ом, создать состояние: <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">counterState = useCounter()</code>. Но я ленивый, мне лень писать через точечку. Я вот здесь сразу выполню деструктуризацию, разберу его на две переменные: <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">getCounter</code> и <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">setCounter</code>.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:12:23 --- И теперь в моем коде я пишу <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">setCounter(getCounter() + 1)</code>.</p>
    <img :src="img6" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Использование деструктурированных функций в коде: const {getCounter, setCounter} = useCounter()]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Очевидно, что такая же логика поедет сюда. А здесь будет еще проще логика: <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">setCounter(0)</code>. Обратите внимание, чего мы добились: <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">теперь у меня просто физически нет возможности изменить состояние counter, забыв обновить его на экране</code>.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:12:44 --- Если вы писали до этого на React, то вот этот код, не считая квадратных скобочек и мелких дополнительных нюансов, очень уж должен напомнить вам хук <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">useState</code>. Это подход, который решил применить у себя React. То есть, грубо говоря, <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">мы прячем состояние внутри определенных функций и предоставляем инструменты для работы с этим состоянием снаружи</code>. Таким образом, мы не можем никак изменить его в обход.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:13:35 --- Окей. Но Vue говорит: как-то это не очень по-джаваскриптерски, плюс мало ли, а вдруг вот здесь у меня будет не переменная, а объект, а объекты можно мутировать. Слушайте, а давайте мы вспомним, что с незапамятных времен в JavaScript есть возможность <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">определять getter и setter на объектах</code>. И поэтому я создам объект <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">counterState</code>, в котором у меня будет два метода: <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">getValue</code> и <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">setValue</code>.</p>
    <img :src="img7" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Создание объекта counterState с методами getValue и setValue, внутренняя переменная _value]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:14:08 --- Очевидно, что <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">value</code> мне надо где-то хранить, поэтому я буду хранить его в переменной <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">_value</code>, к примеру. <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">getValue</code>, очевидно, будет ее как раз-таки просто возвращать, а <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">setValue</code> вообще-то будет ее присваивать: <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">this._value = newValue</code>. Хорошо. Теперь, очевидно, мне снова понадобится функция <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">renderCounter</code>, которую я, пожалуй, опрометчиво удалил.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:14:45 --- Опишу ее ниже, чтобы она видела функцию counterState.</p>
    <p class="font-claude-response-body whitespace-normal break-words">(выше)[SCREENSHOT: Функция renderCounter, обращающаяся к counterState.value, внутри setValue автоматический вызов renderCounter()]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Она будет выглядеть, очевидно, как <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">counterButton.textContent = 'счетчик: ' + counterState.value</code>, и в сеттере буду всегда вызывать функцию <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">renderCounter</code>. Теперь мне надо будет не забыть, поскольку у меня теперь объект, здесь написать <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">counterState.value</code>, очевидно же. И вместо всех этих причандалов <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">setCounter</code> мне надо написать <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">counterState.value += 1</code>.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:15:28 --- Согласитесь, стало выглядеть красивее.</p>
    <img :src="img8" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Обновленный код с более чистым синтаксисом: counterState.value += 1, counterState.value = 0]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Здесь <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">counterState.value = 0</code>. Ну и здесь, очевидно, <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">counterState.value += 1</code>. И, как видите, оно опять заработало. Давайте вернем логику для <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">classList.toggle</code>, <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">isCounterTooBig</code>. Доходим до 10 — все снова работает. Прекрасно.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:15:55 --- <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Мы только что построили реактивность так, как она работала во Vue.js 2</code>. Мы добавляли getter и setter. Vue магическим образом добавлял их к объектам. Это имеет определенные недостатки. <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Ключевым недостатком является то, что если у объекта counterState появится какое-нибудь новое поле newValue, оно не будет реактивным</code> — мы не будем его отслеживать, потому что у нас нет getters и setters для него, нам надо озаботиться установкой getters и setters вручную.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:16:20 --- Но с ECMAScript 2015 есть метод и получше.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:16:50 --- Этот метод называется использование <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Proxy</code>.</p>
    <img :src="img9" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Упоминание Proxy как обертки над объектом]</p>
    <p class="font-claude-response-body whitespace-normal break-words"><code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Proxy оборачивает наш объект в дополнительную обертку, которая позволяет перехватывать обращение к произвольным полям объекта</code>. То есть вы обращаетесь к <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">counterState.value</code>, и мы можем выполнить определенную логику на get и set. Это современное решение, которое не требует предварительного определения getters и setters для каждого свойства — Proxy может перехватывать доступ к любым свойствам объекта динамически.</p></div></div>
  <div><div class="grid-cols-1 grid gap-2.5 [&amp;_&gt;_*]:min-w-0 !gap-3.5"><h1 class="font-claude-response-title mt-1 text-text-100">Основы Vue — Реактивность (Продолжение)</h1>
    <h2 class="font-claude-response-heading text-text-100 mt-1 -mb-0.5">Пересказ видеоурока</h2>
    <hr class="border-border-300 my-2">
    <p class="font-claude-response-body whitespace-normal break-words">00:17:17 --- Переписать пример с использованием вызова <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">newProxy</code> оставляю на ваше усмотрение — это позволит закрепить понимание того, как работает реактивность во Vue 3, ведь она именно на Proxy и основана. А сейчас бессовестно импортирую функцию <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">ref</code> из Vue. Функция <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">ref</code> во Vue делает абсолютно то же самое, что делал в предыдущих примерах вручную.</p>
    <img :src="img10" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код с импортом - import { ref } from 'vue']</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:17:50 --- Она создает объект, у которого есть поле <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">value</code>, и в соответствии с этим полем value происходят все изменения. Если сейчас вызову renderCounter, видим, что выводится счетчик 5.</p>
    <img :src="img11" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Вызов функции renderCounter и вывод в консоли "счетчик 5"]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:18:15 --- Но как же отслеживать изменения? Для этого есть функция <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">watch</code> во Vue. Обращаю внимание: если <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">ref</code> будем постоянно использовать при разработке, то watch — это на самом деле такой фолл последней надежды. Детально разберем это позже, но сейчас для демонстрации реактивности это подходит отлично. Можно сказать: следи за объектом counterState, и когда он изменился — вызови функцию renderCounter.</p>
    <img :src="img12" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код с функцией watch - watch(counterState, () =&gt; { renderCounter() }), счетчик начинает автоматически обновляться на экране]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:18:47 --- И счетчик опять пошел! Но можно еще лучше. Во Vue есть, кроме функции watch, функция <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">watchEffect</code>. Обратите внимание: в watchEffect передаю только функцию renderCounter.</p>
    <img :src="img13" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код - watchEffect(renderCounter) или watchEffect(() =&gt; renderCounter())]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:19:12 --- Можно написать и вот так, но, как показала практика, хоть это и смотрится в разы эстетичнее, у людей почему-то вызывает небольшое подвисание. Когда использую еще одну ненужную обертку в виде анонимной функции, людям это понятнее. Но подождите — как Vue понимает, когда нужно вызывать renderCounter? Обратите внимание: можем отслеживать обращение и на set, и на get, и вызывать перерисовку.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:19:49 --- Что делает Vue? Vue видит: эй, мне передали в watchEffect функцию — и сразу же вызывает эту функцию. Функция внутри обращается к полю value у counterState.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:20:08 --- Перехватываем это благодаря тому, что можем перехватывать get. Ага! Это значит, что эта функция зависит от counterState, раз к нему обращаемся. Поэтому когда поле counterState будет изменяться, буду автоматически вызывать перерисовку. Круто, правда? Но можно еще лучше. Обратим внимание на особенную функцию isCounterToBig, которая проверяет условие и фактически возвращает логику, зависящую от состояния.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:20:49 --- То есть что-то, что можем посчитать только исходя из текущего состояния. Видите, она не принимает аргументов и обращается к нашему состоянию. Это так называемое <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">вычислимое свойство</code> (computed property). Вычислимое, потому что это то, что можно посчитать.</p>
    <img :src="img14" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код исходной функции - function isCounterToBig() { return counterState.value &gt; 10; }]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:21:07 --- Оно во Vue вызывается с помощью функции <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">computed</code>. Можно написать, что const isCounterTooBig — это computed, вычислимое свойство от counterState.value больше 10. И теперь isCounterTooBig и counterState ведут себя одинаково — это объектики, у которых есть поле value внутри, и поэтому здесь надо написать isCounterTooBig.value, чтобы это работало.</p>
    <img :src="img15" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Преобразованный код - const isCounterTooBig = computed(() =&gt; counterState.value &gt; 10), демонстрация использования isCounterTooBig.value]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:21:43 --- После этого проверим: watchEffect, renderCounter, открываем консоль, смотрим на ошибки.</p>
    <img :src="img16" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Открытая консоль с ошибками]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:21:53 --- MyIdentifierIsCounterTooBig has already been declared — потому что надо, конечно же, удалить старую функцию. И оно опять пошло! Скажете: ну а в чем же соль, добавили какую-то одну переменную, зачем? Следите за руками: вставляю вызов функции renderCounter с console.log, который будет говорить о том, что наша функция вызвана.</p>
    <img :src="img17" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Консоль с логом "функция вызвана", счетчик работает корректно]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:22:29 --- Видим, абсолютно ожидаемо — наша функция вызывается каждый раз, на каждый тик. Если щелкать быстрее, будет вызываться быстрее. Теперь же разобью функцию renderCounter на две. Одну оставлю — она будет называться renderCounter, а другая будет называться, допустим, updateCounterColor.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:22:56 --- И делать ровно это. И скажу то же самое: watchEffect updateCounterColor. Ничего не поменялось, казалось бы. Но смотрите за руками: добавляю сюда console.log с текстом "Color".</p>
    <img :src="img18" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Две отдельные функции - renderCounter и updateCounterColor, два вызова watchEffect]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:23:23 --- Открываю HTML. Смотрите: вызвался лог "HTML", вызвался "Color". И Color больше не вызывается! Представьте, что вот здесь, вместо просто изменения цвета, была бы какая-нибудь тяжелая логика обновления HTML. Только что волшебным способом получили возможность не перерисовывать кусок HTML.</p>
    <p class="font-claude-response-body whitespace-normal break-words">(выше)[SCREENSHOT: Консоль, показывающая многократный вызов "HTML" и однократный вызов "Color"]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:24:05 --- А за счет чего? Потому что Vue видит абсолютно по той же логике updateCounterColor. Говорит: ага, значит наша функция updateCounterColor зависит от чего? Она зависит от нашей обертки, в которой лежит true или false — это isCounterTooBig, которая, в свою очередь, посчитана от нашего объекта, в котором лежит value со значением 6.</p>
    <img :src="img19" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Концептуальная диаграмма зависимостей: counterState (value: 6) → renderCounter (зависит от counterState) → isCounterTooBig computed (value: false, зависит от counterState) → updateCounterColor (зависит от isCounterTooBig)]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:24:38 --- А это будет функция renderCounter.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:24:43 --- И дальше происходит цепочка: неважно каким образом изменяем counterState — Vue говорит: эй, так от изменения состояния counterState зависит функция renderCounter, вызываю ее радостно. И зависит вот это computed, вычислимое свойство. Оно проверяет: так, value все еще меньше 10, здесь как было false, так и осталось.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:25:23 --- И раз здесь как было false, так и осталось — зачем буду вызывать функцию updateCounterColor, если значение не поменялось? Когда же здесь значение становится 11, значение изменяется с false на true, и Vue такой: о, значение поменялось!</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:25:43 --- Пришло время вызывать функцию updateCounterColor. Обратите внимание: не написав ничего особенного — единственное, что сделали, показали, что вот это свойство isCounterTooBig зависит от состояния — получили возможность точечного изменения HTML. И вот это второе определение реактивности, о котором говорил.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:26:13 --- Это то, что часто называют <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">fine-grained reactivity</code>. Не существует хорошего перевода этого на русский язык, потому что если перевести дословно, это называется мелкозерновая реактивность. Но предпочитаю назвать ее <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">точечной</code> или <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">высокоточной реактивностью</code>. То есть можем перерисовывать элементы странички и элементы HTML только тогда, когда данные, которые они отображают, изменились.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:26:42 --- Как в нашем случае: изменяем цвет кнопочки только тогда, когда изменилось состояние isCounterTooBig — а точнее не состояние, а <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">вычислимое свойство</code> от состояния. Учимся применять правильные термины. Окей, сразу для тех, кто уже знаком с Vue: а как же reactive и прочее? До этого дойдем, этого еще коснемся, пока задача — поговорить о реактивности.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:27:15 --- Ложечка дегтя во всем этом. Важно понимать, что Proxy оборачивает объект. Что это означает? Представим, что в counterState изначально лежит — у меня есть const initialState, в котором лежит объект с полем counter, равным единице.</p>
    <img :src="img20" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Изменение кода - const initialState = { counter: 1 }, counterState = ref(initialState)]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:27:40 --- То есть раньше там лежало число, а теперь лежит объект. Оборачиваю его в ref, теперь в поле value лежит объект с полем counter. Не забываю, надеюсь, нигде обновить. Вот видите — выводится счетчик undefined.</p>
    <img :src="img21" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Обновление всех обращений к .value.counter, сначала показывает undefined]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:28:09 --- И почему? И здесь соответственно точно так же не забываю обновить — value.counter, value.counter, value.counter — все, счетчик пошел! И isCounterTooBig точно так же. Интересно, почему красный цвет? Потому что здесь, конечно же, просто .value — это я чушь написал. Вот, получаем искомый результат. То есть, казалось бы, что поменялось?</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:28:56 --- Если раньше оборачивал просто число, то теперь в value лежит ссылочка на вот этот объект.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:29:11 --- Окей, здесь срабатывает магия: когда во Vue у прокси берем поле, которое тоже является объектом, оно тоже оборачивает его в Proxy. Как это можем проверить?</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:29:36 --- Очень просто. Смотрите: выведу console.log для initialState и выведу counterState.value. И откроем консольку. Давайте еще раз обновим.</p>
    <img :src="img22" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код с console.log(initialState) и console.log(counterState.value)]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:30:05 --- Обратите внимание: одно вывелось как просто объект с counter — это наш объектик вот этот. А второе вывелось с надписью Reactive. Это используется в DevTools. Если посмотрим внимательно, то это на самом деле Proxy. То есть оно обернуло внутреннее значение поля counterState.value в Proxy.</p>
    <p class="font-claude-response-body whitespace-normal break-words">(выше)[SCREENSHOT: Консоль, показывающая два вывода - первый как обычный объект, второй как "Reactive" (Proxy)]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:30:33 --- Чем это чревато? А это чревато ровно одной вещью. Смотрите: если вот здесь обновлю counter не в counterState, а в initialState, то у меня сломается реактивность. Смотрите: она начинает вести себя, как раньше было, когда забывал в setInterval обновление поставить.</p>
    <img :src="img23" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код с ошибочным обновлением - initialState.counter++]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:31:04 --- Почему так происходит? Потому что внутри нашего объекта initialCounter обновляем вот этот объект. Но Vue ничего не знает об этом. Сделали это в обход прокси. У нас сохранилась прямая ссылочка на вот этот внутренний объект, а не на обертку Proxy. И поэтому Vue не смогло отследить это.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:31:28 --- Это единственный, наверное, специфический большой способ потерять реактивность, что было болью во времена Vue 2, но теперь не является такой болью во времена Vue 3. То есть, грубо говоря, в реальности, если хотим соблюдать реактивность, то должны как можно раньше обернуть сущность в ref и таким образом добиться результата.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:31:54 --- Для тех, кто хочет максимально закрепить, рекомендую повторить этот пример с нуля самостоятельно. Нет, исходников не дам, чтобы не копипастили. То есть написать страничку, на которой есть две кнопки, которые обновляются, и потом написать это на getter и setter, написать это на new Proxy, подключить watchEffects, computed и получить желаемый эффект — и таким образом понять, почему нам это важно.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:32:20 --- Что у нас неприятного? Уберу, чтобы хранили все-таки в чистом виде число, чтобы не было лишнего поля. То есть везде убираю .counter, потому что состояние у нас вроде бы просто число.</p>
    <img :src="img24" width="300" alt="Image" >
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Удаление .counter из кода, возврат к простой структуре с числом]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:32:57 --- А по итогу вынуждены везде тягать за собой вот эту точку value. Да, это так, и ничего с этим в общем виде сделать нельзя. Почему? Потому что Proxy могут оборачивать только объекты. Увидим, как Vue немножечко хитрит в шаблонах для того, чтобы облегчить нашу участь с этим.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:33:19 --- Но в общем и целом действительно везде в коде явно пишем точка value. Те, кто, как говорится, алды помнят — раньше существовало так называемое предложение <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Reactivity Transform</code>, которое должно было волшебным способом преобразовывать код, дописывая там, где надо, точечку value, но от этого отказались, потому что слишком много магии — это тоже плохо.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:33:46 --- Вот перед вами реактивность. Теперь вы знаете, что <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">реактивность</code> — это способность системы реагировать на изменения данных, в нашем случае это просто обновляя интерфейс пользователя, а <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">fine-grained reactivity</code> — опять же, на русский не существует устоявшегося перевода, перевожу как точечная или высокоточная реактивность — это способность перерисовывать только те элементы интерфейса, данные для которых обновились.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:34:20 --- Это то, что, к примеру, React не умеет из коробки — для этого там надо танцевать с бубном вокруг мемоизации, и там просто перерисовывается весь компонент. А Vue, благодаря магии Proxy, благодаря тому, что может отслеживать не только сеттеры, но и геттеры, обеспечивает нам это волшебным, дешевым образом.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:34:45 --- Традиционно в описании под видео будут ссылки на разделы документации Vue, которые рекомендую прочитать после того, как просмотрели видео — там в принципе рассказано плюс-минус то же самое другими словами.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:35:02 --- А на этом на сегодня все. В следующий раз поговорим о втором столпе Vue, а именно о декларативности и что подразумеваем, когда говорим о декларативном DOM или, на самом деле, корректнее, конечно же, использовать термин, как это говорит Vue — декларативный HTML.</p></div></div>
</template>
<script setup lang="ts">
import img1 from '@/assets/vuedush/vuedush1/1.PNG';
import img2 from '@/assets/vuedush/vuedush1/2.PNG';
import img3 from '@/assets/vuedush/vuedush1/3.PNG';
import img4 from '@/assets/vuedush/vuedush1/4.PNG';
import img5 from '@/assets/vuedush/vuedush1/5.PNG';
import img6 from '@/assets/vuedush/vuedush1/6.PNG';
import img7 from '@/assets/vuedush/vuedush1/7.PNG';
import img8 from '@/assets/vuedush/vuedush1/8.PNG';
import img9 from '@/assets/vuedush/vuedush1/9.PNG';
import img10 from '@/assets/vuedush/vuedush1/10.PNG';
import img11 from '@/assets/vuedush/vuedush1/11.PNG';
import img12 from '@/assets/vuedush/vuedush1/12.PNG';
import img13 from '@/assets/vuedush/vuedush1/13.PNG';
import img14 from '@/assets/vuedush/vuedush1/14.PNG';
import img15 from '@/assets/vuedush/vuedush1/15.PNG';
import img16 from '@/assets/vuedush/vuedush1/16.PNG';
import img17 from '@/assets/vuedush/vuedush1/17.PNG';
import img18 from '@/assets/vuedush/vuedush1/18.PNG';
import img19 from '@/assets/vuedush/vuedush1/19.PNG';
import img20 from '@/assets/vuedush/vuedush1/20.PNG';
import img21 from '@/assets/vuedush/vuedush1/21.PNG';
import img22 from '@/assets/vuedush/vuedush1/22.PNG';
import img23 from '@/assets/vuedush/vuedush1/23.PNG';
import img24 from '@/assets/vuedush/vuedush1/24.PNG';
</script>