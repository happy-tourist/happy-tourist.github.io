<template>
  <div><div class="grid-cols-1 grid gap-2.5 [&amp;_&gt;_*]:min-w-0 !gap-3.5"><p class="font-claude-response-body whitespace-normal break-words">00:00:20 --- Миска, миска, миска. Бывало ли у вас такое, что ваш мозг цепляется за звук какого-то слова, и чем больше раз вы его повторяете, тем меньше смысла оно для вас несет, превращаясь просто в набор бессвязных звуков? Ставьте лайк, если вы тоже, как и я, такой старый, что помните, из какого сериала эта отсылка. Вот примерно так же и со словом <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">декларативность</code> у меня. На самом деле, если не стесняться неправильных определений, <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">декларативность</code> — это когда мы описываем результат, а не способ его получения. Но поскольку без иллюстрации это всего лишь точно так же набор пустых звуков, то давайте разбираться, почему же декларативность для меня все больше превращается просто в набор звуков.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:01:31 --- И разберемся на конкретном примере. Представьте себе, что вы пришли собеседоваться на должность, допустим, джуниор-разработчика. И я или кто-то хочет протестировать ваши навыки базового JavaScript. Говорят: смотри, у нас тут есть div с ID colors. Можешь сделать так, чтобы по клику на кнопочку add сюда добавлялся div с классом color и случайным цветом, ну заливкой, а по reset все убиралось. Но вы же хотите показать, что вы умный, да? И вы такие: оператор, оператор, а фреймворк использовать можно? Какой фреймворк? В смысле Vue. Нет, мы все-таки собеседуемся на чистом JavaScript. Но это же только реактивность. Ладно, реактивность можно.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:02:37 --- И мы с вами радостно импортируем из Vue то, что мы знали уже в прошлый раз: <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">watchEffect</code> и <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">ref</code>. Поскольку мы с вами уже умницы и знаем, что программирование современного фронтенда — это в том числе про <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">разделение состояния и представления</code>, мы сразу говорим: значит, у нас будет состояние, это массив наших цветов. Очевидно, что это будет ref от массива. И там будем хранить вот такие конструкции: красный, синий, зеленый. Ну и вставим для теста две штучки. Давайте три, чтобы красиво было.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код редактора показывает импорт watchEffect и ref из Vue, создание реактивного состояния colors = ref([]) с объектами {r, g, b} для красного, синего и зеленого цветов]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:03:06 --- Теперь мы говорим, значит, напишем. Я напишу <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">watchEffect</code>, который будет реагировать на изменение colors. Реагировать он будет магически, потому что мы просто обратимся к нему. Так работает watchEffect. Значит, я нахожу контейнер, куда надо нам все это рисовать — querySelector colors. Бессовестно его очищаю. И дальше говорю: для каждой записи в массиве colors, не забывая писать value, я создаю DOM-узел, даю ему, как меня и попросили, класс color. Дальше я даю ему, очевидно, стиль, заливку, background color. Это rgb — r, g, b. И, естественно, не забываю сделать container appendChild, добавить элемент node. Та-дам! Смотрите, они у меня вывелись.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код watchEffect с полной логикой рендеринга - поиск контейнера, очистка, forEach по colors.value, создание div-элементов с классом color, установка background через rgb и appendChild в контейнер. В браузере видны три цветных блока]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:04:29 --- А можешь сделать так, чтобы граница у них тоже была такого же цвета, как заливка, только потемнее? Да, конечно. Конечно же, умный джун, возможно, мог бы тут использовать computed, но на самом деле здесь без разницы. Так что берем borderColor, умножаем на 0.8 каждое число. И получаем вот такую красоту.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Дополненный код с node.style.borderColor, где каждое значение RGB умножено на 0.8. Цветные блоки теперь отображаются с более темными границами того же оттенка]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:04:48 --- Теперь, поскольку вот эта логика полностью отвечает у нас за то, как массив рисуется на экране, в add мне просто надо сделать colors.value.push, добавить элемент в массив, и сгенерировать в полях r, g и b случайное число от 0 до 255. Math random на 255, Math random на 255. Ой, поломалось. Но поскольку это тестовый у нас типа лайфкодинг, мы скажем: окей, неважно. А здесь просто очевидно обновить массив, обнулить массив.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код обработчиков кнопок - для add показан colors.value.push с генерацией случайных RGB значений через Math.random() * 255, для reset - colors.value = []. Демонстрация работы кнопок в браузере]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:05:49 --- Эта логика прекрасна. Но что же меня напрягает? Меня напрягает вот эта неиспользованная переменная size. И мне говорят: а теперь давай добавим в index.html еще одну кнопочку, которая будет называться shuffle и которая должна перетасовывать их. И вы такой: боже, это же писать перемешивание, я не помню. Не-не-не. У нас собеседование не про это. Ты можешь использовать shuffle из библиотеки Lodash. Так, господи, а в чем проблема? Смотрите, какая у меня гибкая структура. Я говорю: найти кнопочку абсолютно аналогично, button shuffle. Добавить слушатель клик. И при клике я просто говорю colors.value равно shuffle colors.value.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: HTML с новой кнопкой shuffle, код обработчика с querySelector для кнопки shuffle и использованием lodash shuffle. Добавлен CSS для body с большим margin-top, чтобы кнопки не закрывали лицо]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:06:50 --- Смотрите, работает! Но не все так просто. Я хочу, чтобы когда shuffle происходил, эти кнопочки менялись местами. Давайте, кстати, чтобы они не закрывали мое лицо, дадим body большой margin top, чтобы оно было вот так. А я хочу, чтобы они красиво летели, когда ты их перемешиваешь.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:07:28 --- Приехали. Так. Красиво летели. Это означает, что теперь я не могу проводить вот этот финт, когда я каждый раз просто напрочь удаляю все, что было, и заново рисую. Плохо, плохо. Это означает, что мне надо будет каждый раз проверять, есть ли у меня уже элемент текущего цвета. Если есть, то его не надо создавать, его надо как-то переместить и анимировать. Окей, давайте разберемся с анимацией.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:08:14 --- Анимировать я хочу через CSS с transitions, и анимировать я буду так: теперь они будут позиционированы. Предположим, что в рамках собеседования это нормально. Я буду их позиционировать через <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">transform</code>. И благодаря transition all 0.5 секунд они будут у меня красиво лететь.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: CSS код с добавлением transition: all 0.5s и position: absolute для элементов с классом color. Объяснение проблемы - нельзя просто удалять и пересоздавать все элементы, нужно переиспользовать DOM-узлы]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:08:40 --- То есть я теперь добавляю сюда еще node.style.transform равно translateX. И вот мне пригодилась вот эта переменная size. Неспроста ж она тут нас ждала. Size умножить на i. И что еще нам может быть важно? Давайте посмотрим, почему оно не сработало, потому что, конечно же... нет, transform все правильно. Node.style.transform, translateX, size умноженный на i. Ну конечно же! Так, и теперь size, а, ну и, конечно же, i — откуда возьмется индекс? Да, его надо у forEach забрать.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Модифицированный код где forEach получает второй параметр (color, i), добавлен node.style.transform = 'translateX(' + size * i + 'px)'. Видна отладка с поиском ошибки и исправлением. Цветные блоки теперь расположены горизонтально с использованием transform]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:09:44 --- Вот, смотрите, теперь они у меня, я могу... они вот снова стали на место.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:09:57 --- И теперь я напишу следующую логику. Так, логика очистки. If colors.value.length == 0, то мы очищаем наш контейнер и сразу выходим. А если нет, то теперь делаем следующее. Я первым делом ищу, а нет ли узла с текущим цветом. Только искать его по перебору всех элементов скучно. Давайте я сделаю так: я вот эту же конструкцию засуну в айдишник. Да, я знаю, что правильнее это делать, засунув ее, к примеру, в data-id. Но вот мне так хочется. Зачем — будет понятно в самом конце. Простите мне, как говорится, минутную слабость.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:10:58 --- И я, значит, пишу, что вначале мы ищем... давайте это наша строка цвета. Значит, я ищу ноду — не в документе, а в контейнере — я ищу ноду с классом color, у которой id-шник мой colorStr. Если такая нода найдена, то это означает, что у меня уже есть этот цвет, и ее не надо создавать. Если же ее нет, то ее надо, очевидно, создать.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:11:36 --- Убираю здесь const. Вот создаю ноду. Цвет у нее... И независимо от того, есть нода или нет, мне надо добавить ей transform. Здесь надо все равно сделать appendChild только для новых, но transform для того, чтобы она могла сменить свой translateX. То есть если я каждый раз ищу узел... и давайте здесь, чтобы убрать повторение, node.style.backgroundColor равно colorStr, чтобы убрать повторение... я говорю: если элемента с таким цветом нет, я его создаю. Предположим, что я такой сказал: ну, нам по-хорошему вот здесь надо добавить проверку на то, что цвета не повторяются в таком случае. Ну, мне сказали: окей, можно пока не заморачиваться. Вероятность того, что вылетят два одинаковых цвета, крайне мала, поэтому ради сохранения времени на собеседовании это так вот.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Рефакторинг кода watchEffect с логикой переиспользования узлов - проверка if (colors.value.length === 0) для очистки, создание colorStr из rgb, поиск существующего элемента через querySelector с селектором .color[id="colorStr"], условное создание узла только если он не найден, установка transform для всех узлов независимо от того новые они или существующие, appendChild только для новых узлов]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:12:36 --- Если элемента с таким цветом у меня нет, я его создаю, и независимо от того, только его сейчас создал или нет, я его размещаю согласно индексу его в массиве. Смотрите! Получилось классно, правда?</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Демонстрация работы приложения - при нажатии shuffle цветные блоки плавно перемещаются на свои новые позиции с анимацией благодаря transition и правильной установке transform]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:13:04 --- Но будем откровенны. Вот давайте посмотрим внимательно на вот этот код, который у меня в watchEffect. У меня максимально примитивная приложенька. И вот насколько она была простой и прекрасной, пока мне не понадобилось вот это вот — реализовывать анимацию. Для того чтобы у меня была анимация, мне теперь... ну, если раньше просто каждый раз рисовал все заново, а теперь мне надо переиспользовать DOM-узлы для того, чтобы вот была вот эта анимация.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Сравнение двух подходов - простой код с полной перерисовкой vs сложный код с переиспользованием узлов. Визуальное выделение разницы в количестве строк и сложности логики]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:13:30 --- Что же делать, что же делать, что же делать? А что если я... а можно использовать библиотечку, которая позволит мне взять лучшие из двух подходов? То есть сохранить анимации, но в то же время сохранить, грубо говоря, простой рендеринг. Ну ладно, мы тебе даже подскажем библиотечку, она называется <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">MorphDom</code>. Внимание, эта библиотека исключительно в иллюстративных целях, и у нее ровно одна функция.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Упоминание библиотеки MorphDom как решения дилеммы между простотой кода и функциональностью анимаций. Текст на экране подчеркивает, что библиотека используется только для демонстрации]</p></div></div>
  <div><div class="grid-cols-1 grid gap-2.5 [&amp;_&gt;_*]:min-w-0 !gap-3.5"><h1 class="font-claude-response-title mt-1 text-text-100">Основы Vue - Декларативность (Пересказ)</h1>
    <p class="font-claude-response-body whitespace-normal break-words">00:14:08 --- Продолжаю рассказывать об основах Vue и сегодня разберём <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">декларативный подход</code> в программировании. Даю библиотеке одно дом-дерево, второе дом-дерево, и она превращает первое во второе, трансформирует его. Смотрите, как это работает: беру текущий контейнер — назовём его existing контейнер, в котором лежит то, что сейчас отображается на экране. В этом контейнере создаю новый div.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код редактор с настройкой контейнера - создание переменной existing контейнер и нового div элемента с id="colors", демонстрация замены одного элемента другим]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Если вам непонятен конкретно этот момент, объясню зачем пишу следующие две строчки.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:14:45 --- Делаю это для того, чтобы заменять один элемент с <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">id colors</code> на другой. Обратите внимание — это не div container, а именно id colors. Дальше наполняю этот контейнер. При этом важный момент: контейнер пуст, поэтому в нём нет смысла искать существующие ноды.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код с инициализацией пустого контейнера, визуальная демонстрация структуры контейнера, комментарии или маркеры показывающие пустое состояние]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:15:06 --- Всё время буду делать вот так: нод, нод, нод, нод — создаю узлы для каждого элемента в массиве <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">colors</code>. Потом засуну всё в контейнер. Могу сделать даже красивее — смотрите, для каждого элемента colors создаю узел, причём могу прямо показать, что эти узлы у меня node1, node2 больше не зависят от порядка, потому что их позиционирую по node1.id.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код создания узлов node1, node2 и т.д., реализация функции сортировки сравнивающей node1.id с node2.id, визуализация логики сортировки - если node1.id больше node2.id возвращает 1, иначе -1, сортировка по полю ID или полю цвета]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:15:37 --- Если node1.id больше node2.id, то возвращаю 1, иначе минус 1 — обычная сортировка по полю ID, по полю цвета.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:15:47 --- Потом говорю, что каждый элемент, который у меня получился, добавляю в контейнер через <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">appendChild</code>. Немножко выпендриваюсь — смотрите, для каждого цвета, который есть в массиве, создаю DOM-узел, дальше их сортирую, и все эти узлы добавляю в контейнер. А дальше просто говорю <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">morphDOM</code>: пожалуйста, преврати то, что сейчас лежит в контейнере, в то, что я сгенерировал заново.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Полный код с циклом forEach создающим узлы, вызовы appendChild() добавляющие узлы в контейнер, вызов функции morphDOM с параметрами, визуальный результат - анимация работает корректно с новым подходом]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:16:34 --- Смотрите, оно заработало точно так же! Давайте ещё раз проверю. А, могу теперь вот это убрать.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код с удалёнными или закомментированными строками, визуальная демонстрация работы shuffle, визуальная демонстрация работы reset, экран показывающий успешные анимации]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Убираю, и reset тоже работает.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:16:53 --- Посмотрите, насколько проще снова стал мой код! Мне не надо думать, есть ли существующие узлы или нет существующих узлов. Просто говорю: хочу увидеть на экране узлы вот в таком-то порядке. А дальше библиотека <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">MorphDOM</code> говорит: так, у меня есть вот это на входе, вот это на выходе, и берёт, делает всю грязную работу за нас. Сохраню этот код и откачу назад, чтобы показать, что приходилось делать раньше.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Разделённый экран или сравнение старого и нового кода, старый код показывающий проверку - если массив пустой очистить элемент, иначе искать элементы в массиве и т.д., новый код показывающий простое создание узлов и вызов morphDOM, визуальное выделение разницы в сложности, код с комментариями показывающий переподключение библиотеки MorphDOM]</p>
    <p class="font-claude-response-body whitespace-normal break-words">До того как использовали библиотеку, нам приходилось самостоятельно писать: ага, если массив пустой — очистить элемент, иначе искать элементы в массиве и так далее. То есть прямо писали <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">инструкции</code>, как работаем с DOM по шагам.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:17:20 --- Теперь специально вставлю, закомментирую предыдущий код и подключу снова библиотеку MorphDOM, которую отключил. И shuffle — нечаянно ctrl-z-нул его.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:18:14 --- Так, нет, просто где-то не закрыл</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:18:20 --- комментарий. Да, вот здесь всё. Теперь же смотрите: просто каждый раз рисую заново в HTML, как я хочу, чтобы выглядело это всё. Могу написать вот такую конструкцию: <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">existingContainer.innerHTML</code> равно <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">container.innerHTML</code>. И, естественно, оно не будет анимироваться, потому что узлы создаются новые, как у меня и было раньше.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код показывающий existingContainer.innerHTML = container.innerHTML, визуализация - элементы меняются без анимации, код показывающий вызов функции morphDOM вместо innerHTML, визуализация - те же элементы теперь анимируются плавно, сравнение обоих подходов]</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:19:02 --- Но заменив всего одну эту строчку на функцию <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">morphDOM</code>, получаю желаемый результат. Вот это и есть <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">декларативный подход</code>! Говорю: хочу получить вот такой результат на экране. А как получишь этот результат на экране — уже зависит от тебя.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:19:26 --- Во Vue, когда на следующем занятии будем смотреть на код шаблонов в компонентах, увидим, что мы не описываем: эй, возьми вот этот кусок HTML, сделай с ним то-то, возьми этот кусок HTML, сделай то-то. Не делаем этого. Мы описываем: хочу, чтобы когда мои данные выглядят вот так, наш код выглядел вот так.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:19:58 --- <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Декларативность</code> не является ключевым свойством только Vue. React декларативен, Angular декларативен, Ember — да всё почти декларативно! Не работаем с HTML напрямую, а описываем, что хотим получить.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:20:18 --- Если у вас уже слегка опухла голова, то на этом вполне можете остановиться. Если же хотите быть молодцом, задам вам два нюанса, с которыми предлагаю разобраться самостоятельно и отписать в комментариях. Это видео специально перезаписал вне предыдущих записанных видео, потому что нашёл вот этот классный пример, придумал, и поэтому прям смогу отметить тех, кто будет первый молодец в комментариях.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:20:57 --- На что хочу, чтобы вы разобрались. Первое — простой сценарий. Если закомментирую вот здесь <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">поле ID</code>, обнаружим, что у меня перестала работать анимация. Вопрос: почему так происходит?</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код с видимым и работающим полем ID, код с закомментированным полем ID, визуальное сравнение - с ID плавные анимации с перемещением, без ID только изменение цвета без анимации позиции, экран показывающий сломанное поведение анимации]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Видите, оно перекрашивает их, но явно перестало их двигать.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:21:19 --- Хотя генерирую трансформы и так далее, всё генерирую. Почему так? Для ответа вам надо будет посмотреть, в чём суть библиотеки <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">MorphDOM</code>. Подсказка: подобная особенность есть везде — и в React, и во Vue, абсолютно везде нам приходится использовать что-то похожее</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:21:43 --- на вот такой node id для того, чтобы это работало. Это первое. Второе: на самом деле, когда рассказывал, что я вот такой выпендрёжник и использую <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">sort</code>, мне sort нужен — это специфика работы библиотеки MorphDOM. Предлагаю посмотреть: без него анимации будут работать супер странно — прямо сложно понять, как и почему они работают, почему не работают.</p>
    <p class="font-claude-response-body whitespace-normal break-words">[SCREENSHOT: Код без функции sort(), визуализация - странные непредсказуемые анимации, код с восстановленным sort(), визуализация - анимации снова работают корректно, множественные тестовые запуски показывающие непоследовательное поведение без sort]</p>
    <p class="font-claude-response-body whitespace-normal break-words">Видите, то одно анимируется, то иногда вот два анимируется — вообще странно. Попробуйте разобраться! Это связано с пониманием того, как работает библиотека, и умением пользоваться <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">отладчиком</code>.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:22:23 --- Возможно, запишу бонусное видео, пока посмотрим на вас — если никто не разберётся в этом. Если разберётся, обязательно оставляйте пояснение в комментариях, почему мне пришлось дописать вот этот sort и без него ничего не работает. Вот видите, вернули sort — начало всё работать.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:22:44 --- И последнее. Если смотрите эти видео и приходите к нам из мира React, или может даже знаете Vue, обнаружите, что в этом видео ни разу не произнёс слова, которые раньше, наверное, были бы магическими и звучали в топ 100 процентах случаев. Два этих слова: <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">виртуальный DOM</code> (virtual DOM). Почему? Дальше обязательно, думаю, в каком-нибудь отдельном видео поговорим, что такое virtual DOM и зачем он нужен.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:23:22 --- Но сейчас хочу, чтобы вы знали: специально не использую слова virtual DOM, потому что это <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">детали реализации</code>. То, как работает Vue — сейчас он использует virtual DOM.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:23:36 --- Рано или поздно придёт так называемый <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">VaporMode</code> — новые фишки внутри Vue, связанные с тем, как будет обеспечиваться работа с синхронизацией шаблонов и состояния. И виртуал дома не будет, а Vue останется таким же и неизменным.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:23:55 --- Именно поэтому взял библиотеку <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">MorphDOM</code>, которая не работает с виртуальным DOM, не упоминает его, чтобы вы могли посмотреть на эту концепцию <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">декларативности</code> именно без привязки. Обнаружил, что у многих учеников она почему-то связана с концепцией виртуал дома. И для тех, кто остался, повторение: декларативность — это когда мы описываем, какой результат хотим получить, и не описываем, как его хотим получить.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:24:41 --- Но причём же тут JS, спросите вы? Дело в том, что мы пишем на очень высокоуровневом языке. И когда говорим «создай div с background color» — это тоже своего рода декларативность, ведь мы не говорим: отрисуй мне прямоугольничек с вот такими скруглёнными уголками по 5 пикселей, залей его вот таким-то цветом, после этого обведи по краю этого прямоугольничка border другим-то цветом.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:25:09 --- В то же время, если бы даже делали так, мы же не говорим: возьми вот этот адрес памяти, адрес видеопамяти, запиши туда такие-то байтики, учитывая пользовательское разрешение и так далее. То есть каждый шаг от самого-самого низкого уровня к самому высокому добавляет нам как раз этой <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">декларативности</code>.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:25:36 --- Когда мы описываем, что хотим получить, не задумываясь о том, как это получаем. Но вы же, правда, не думаете о том, как эти все пиксели отображаются в видеопамяти? Надеюсь, не думаете. Именно поэтому сказать, что вот это совсем декларативно, а вот это чётко императивно — сложно. Вот этот код, который мы писали раньше — это <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">императивный код</code>.</p>
    <p class="font-claude-response-body whitespace-normal break-words">00:26:02 --- <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Императивно</code> — это когда я выдаю инструкции, что делать: создай элемент, добавь класс, поменяй его, если нашёл элемент — измени у него стиль и так далее. Поэтому граница, где начинается декларативность и где заканчивается, она размыта, и, наверное, о ней даже не стоит так глубоко заморачиваться. Успехов в поисках, жду ваших комментариев, пока!</p></div></div>
</template>