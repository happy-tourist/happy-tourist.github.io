<template>
<div><div class="standard-markdown grid-cols-1 grid gap-4 [&amp;_&gt;_*]:min-w-0 !gap-3.5"><h1 class="text-text-100 mt-3 -mb-1 text-[1.375rem] font-bold">Лекция по изучению Node.js. Урок 1. Домашнее задание</h1>
<hr class="border-border-200 border-t-0.5 my-3 mx-1.5">
<h2 class="text-text-100 mt-3 -mb-1 text-[1.125rem] font-bold">Отредактированный транскрипт</h2>
<img :src="screenshot_0002" alt="Image" >
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:00:00 --- Всем привет! Представляю вам небольшое домашнее задание после первого урока. Некоторое время размышлял, что именно предложить сделать. Сначала была мысль дать задачу на парсинг Excel-файла в фоновом режиме, чтобы это не блокировало остальных клиентов. Но после обдумывания понял, что это не изменит сути дела — схема останется той же, что мы разбирали на уроке. Ничего творческого в такой задаче не будет, только рутина.</p>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:00:26 --- Поэтому решил предложить поэкспериментировать с немного другой идеей. На первом уроке мы стремились к тому, чтобы запросы за простыми страницами завершались быстро. Но одна из особенностей Node.js заключается в том, что в нём легко организовать запросы, которые выполняются намеренно долго. Зачем нужны такие долгие запросы?</p>
<img :src="screenshot_0055" alt="Image" >
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:00:52 --- Давным-давно ещё не было ни <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Server-Sent Events</code>, ни <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">WebSocket</code>, а когда они появились, браузеры их ещё плохо поддерживали. Но уже тогда существовала необходимость получать данные в режиме реального времени. Что было придумано? Если клиент будет обращаться к серверу запросами каждые 5 секунд, то обновления на стороне клиента будут визуально запаздывать.</p>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:01:18 --- Если нам нужно в реальном времени подгружать ставки на аукционе, как в том примере с автомобилями, который я показывал, или отправлять личные сообщения, или организовать вебинарную комнату — представьте, я рисую что-то на экране, а вы видите это только через 5 секунд. Если уменьшить этот интервал и опрашивать сервер о наличии изменений раз в секунду, возникает другая проблема — слишком большая нагрузка на сеть. Была придумана техника под названием <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Long Polling</code>: запрос от клиента отправляется на сервер и зависает там, пока сервер не получит новые данные и не ответит клиенту.</p>
<img :src="screenshot_0127" alt="Image" >
<img :src="screenshot_0129" alt="Image" >
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:01:53 --- Это решает фундаментальную проблему HTTP-парадигмы: сервер не может принудительно отправить сообщение клиенту по своей инициативе. Предлагаю попробовать сделать простейшую версию этой технологии. Не нужно реализовывать полноценный <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">XHR Long Polling</code> со стороны клиента — там основные усилия требуются именно на клиентской части: переподключения, обработка ошибок и так далее.</p>
<img :src="screenshot_0146" alt="Image" >
<img :src="screenshot_0150" alt="Image" >
<img :src="screenshot_0155" alt="Image" >
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:02:20 --- Покажу, как <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Long Polling</code> выглядит на уровне сайта, где он используется. Откроем вкладку Network в браузере, фильтр XHR. Отправился запрос за ставками.</p>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:02:39 --- Через некоторый таймаут он вернётся с ответом, что новых ставок не было. Если бы кто-то сделал ставку, этот запрос моментально вернул бы ответ, что на сервере обнаружена новая ставка, и сразу же отправился бы следующий такой же запрос за обновлениями ставок. Мы не видим сейчас новый <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Long Polling</code> запрос из-за того, что здесь много других запросов от Яндекс.Метрики и Вебвизора.</p>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:03:10 --- Этот запрос постепенно завершится — точно не помню таймаут, 60 или 30 секунд — и после него начнётся новый такой же запрос. Получается, что вместо того, чтобы мучить сервер запросами каждую секунду, мы отправляем один долгий запрос, который зависает на сервере.</p>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:03:31 --- Заметьте важное отличие от PHP: в Node.js зависший запрос не блокирует систему. Это просто <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">macrotask</code>, запущенный для обработки запроса, и установлен таймаут для его завершения. Какой-то <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">macrotask</code> висит в Event Loop, который через 30 секунд завершит этот запрос и ответит клиенту, что изменений не было. Система не нагружается — просто в памяти хранятся активные объекты <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">request</code> и <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">response</code>.</p>
<img :src="screenshot_0242" alt="Image" >
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:03:58 --- Вот что предлагаю попробовать сделать. Вам не нужна клиентская часть — можете тестировать прямо из браузера. Можете убрать все обработчики роутов, оставить только один адрес, например, главную страницу. Называйте как хотите. Смысл в следующем: нужно создать функцию, которая эмулирует наступление события. Придумайте сущность, с которой работаете.</p>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:04:25 --- Это может быть сущность «ставки», если вы смотрели пример с аукционом автомобилей. Это может быть сущность «сообщения», если хотите сделать эмуляцию чата. У вас будет функция, добавляющая новую сущность. С реальной точки зрения, вызов этой функции происходит, когда кто-то обращается к серверу методом POST: отправляет ставку, отправляет новое сообщение в чат и так далее.</p>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:04:53 --- Вам не нужно делать POST-обработчик. Подвесьте функцию <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">addItem()</code> на случайный таймаут или интервал. Пусть эта функция <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">addItem()</code> вызывается в промежутке времени от 30 до 60 секунд постоянно. Эти элементы можете складывать в массив, а можете и не складывать. Когда пользователь обращается к главной странице, не нужно сразу вызывать <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">response.end()</code> — пусть этот запрос висит в режиме ожидания.</p>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:05:24 --- Например, установим такое условие: если запрос провисел 30 секунд в режиме ожидания, он завершается с ответом <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">null</code>, что означает отсутствие новых данных. Если пока <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">response</code> активен, произошло добавление нового элемента через <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">addItem()</code>, то <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">response</code> возвращает именно этот новый элемент. Как подписаться на событие добавления нового элемента — решайте сами.</p>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:05:49 --- Можно организовать простую событийную систему с использованием <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">EventEmitter</code>. Можно создать <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Proxy</code> вокруг массива, который будет отслеживать изменения. Можно сделать так, чтобы <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">addItem()</code> вызывала функцию, которая имеет доступ к активным объектам <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">response</code> и завершает их. На практике в реальных приложениях создают массив активных клиентов, подписанных на изменения. Когда происходит <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">addItem()</code>, все активные объекты <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">request</code> и <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">response</code> складываются в этот массив клиентов. После <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">addItem()</code> проходят циклом по всем клиентам и рассылают им обновление.</p>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:06:24 --- Выбор подхода за вами — здесь множество вариантов реализации. Главное — реализовать хотя бы один способ, чтобы прочувствовать эту идею Node.js: не всегда мы хотим, чтобы запрос быстро завершился. Иногда, наоборот, запрос клиента живёт очень долго, и мы хотим, чтобы он, не тратя ресурсов, висел на сервере до нужного момента завершения.</p>
<img :src="screenshot_0411" alt="Image" >
<img :src="screenshot_0413" alt="Image" >
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:06:50 --- Попробую ещё раз обрисовать задачу. Вы делаете запрос на главную страницу, и запрос зависает максимум на 30 секунд. Если в течение этого времени интервал, случайно добавляющий новые элементы, создаёт элемент, то в этот же момент мы отдаём этот элемент клиенту.</p>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:07:13 --- Соответственно, если элемент в течение 30 секунд не добавился, возвращаем <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">null</code> в браузер, и вы увидите этот <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">null</code>. В реальной реализации со стороны клиента JavaScript отправляет запрос на сервер. Сервер возвращает либо элементы, либо <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">null</code> по таймауту, после чего запрос просто повторяется. Получается один запрос в 30 секунд вместо одного запроса в секунду.</p>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:07:39 --- Никаких задержек нет. Это древняя технология, которая активно использовалась в начале 2010-х годов, пока <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">WebSocket</code> не вошёл в активное использование. Например, сообщения ВКонтакте работали на <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">XHR Long Polling</code> — это было очень хорошо видно в консоли браузера в начале 2010-х. Кстати, если у пользователя старые браузеры и сокеты не работают, то переключение на <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Long Polling</code> как запасной вариант ещё долгие годы существовало в том же ВКонтакте.</p>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:08:08 --- Вам не нужно делать клиентскую часть — просто заходите на эту страницу из браузера и смотрите, как сработает случайность. Либо вы ждёте 30 секунд и получаете <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">null</code>, либо в промежутке от 0 до 30 секунд вам возвращается элемент. Можете установить любое время, потому что понимаю, что 30 секунд иногда долго тестировать. Можете выбрать 10 секунд — это совершенно не принципиально. Главное — показать, как вы видите эту схему.</p>
<img :src="screenshot_0535" alt="Image" >
<img :src="screenshot_0537" alt="Image" >
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:08:35 --- То, как вы будете подписывать объекты <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">response</code> клиентов на их взаимодействие с функцией <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">addItem()</code>, которая вызывается по случайному интервалу — это ваше творчество. Если думаете, что здесь используются темы, которые вы не знаете в Node.js, то от Node.js вам ничего особенного не нужно. Мы уже изучили, что есть объект <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">request</code> клиента и объект <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">response</code>, которым можно завершить ответ клиенту.</p>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:09:01 --- Всё остальное — это знание JavaScript: понимание того, как организовать простую событийную модель, как сделать подписку на события, как использовать геттеры и сеттеры, или создать <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Proxy</code> вокруг массива. Вариантов множество, включая создание массива активных клиентов. Выбор за вами. Если подробно расскажу схему, то творческая составляющая пропадёт. Возможно, я уже рассказал больше, чем следовало.</p>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">00:09:30 --- Попробуйте, поэкспериментируйте, чтобы прочувствовать, как в Node.js запрос может жить дольше, чем мы привыкли в традиционных серверных технологиях.</p>
<hr class="border-border-200 border-t-0.5 my-3 mx-1.5">
<h2 class="text-text-100 mt-3 -mb-1 text-[1.125rem] font-bold">Дополнительные пояснения</h2>
<h3 class="text-text-100 mt-2 -mb-1 text-base font-bold">Long Polling — что это такое?</h3>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]"><code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Long Polling</code> (длительный опрос) — это техника получения данных в реальном времени, при которой клиент отправляет HTTP-запрос на сервер, и этот запрос остаётся открытым до тех пор, пока сервер не получит новые данные для отправки или не истечёт таймаут. После получения ответа клиент немедленно отправляет новый запрос, создавая непрерывный цикл обновлений без постоянной нагрузки на сеть.</p>
<h3 class="text-text-100 mt-2 -mb-1 text-base font-bold">Server-Sent Events (SSE)</h3>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]"><code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Server-Sent Events</code> — это технология односторонней передачи данных от сервера к клиенту через HTTP-соединение. В отличие от <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Long Polling</code>, где каждое обновление требует нового запроса, SSE поддерживает постоянное соединение, через которое сервер может отправлять множественные обновления. Используется для задач, где данные идут только от сервера к клиенту (новости, уведомления, обновления статуса).</p>
<h3 class="text-text-100 mt-2 -mb-1 text-base font-bold">WebSocket Protocol</h3>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]"><code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">WebSocket</code> — это протокол двунаправленной связи, работающий поверх TCP-соединения. В отличие от <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Long Polling</code> и SSE, <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">WebSocket</code> позволяет как серверу, так и клиенту отправлять сообщения друг другу в любой момент через одно постоянное соединение. Это делает его идеальным для интерактивных приложений: чатов, онлайн-игр, совместного редактирования документов.</p>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]"><strong>Сравнение подходов:</strong></p>
<ul class="[li_&amp;]:mb-0 [li_&amp;]:mt-1.5 [li_&amp;]:gap-1.5 [&amp;:not(:last-child)_ul]:pb-1 [&amp;:not(:last-child)_ol]:pb-1 list-disc flex flex-col gap-2 pl-8 mb-3">
<li class="whitespace-normal break-words pl-2"><code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Long Polling</code> — односторонний, новый запрос на каждое обновление, работает везде</li>
<li class="whitespace-normal break-words pl-2"><code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Server-Sent Events</code> — односторонний (сервер → клиент), одно соединение, простая реализация</li>
<li class="whitespace-normal break-words pl-2"><code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">WebSocket</code> — двунаправленный, одно соединение, требует поддержки протокола</li>
</ul>
<h3 class="text-text-100 mt-2 -mb-1 text-base font-bold">Ограничение HTTP-парадигмы</h3>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">В классической HTTP/1.1 парадигме взаимодействие всегда инициируется клиентом: клиент отправляет запрос, сервер отвечает, соединение закрывается. Сервер не может самостоятельно инициировать отправку данных клиенту — он может только ответить на входящий запрос. Это фундаментальное ограничение модели «запрос-ответ». <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Long Polling</code> обходит это ограничение, оставляя запрос открытым и позволяя серверу ответить в удобный момент, когда появятся новые данные.</p>
<h3 class="text-text-100 mt-2 -mb-1 text-base font-bold">XHR (XMLHttpRequest)</h3>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]"><code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">XMLHttpRequest</code> — это API браузера для выполнения HTTP-запросов из JavaScript. До появления <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">fetch()</code> это был основной способ делать асинхронные запросы к серверу без перезагрузки страницы (технология AJAX). XHR позволяет отправлять запросы, получать ответы и обрабатывать их асинхронно, что сделало возможным создание динамичных веб-приложений.</p>
<h3 class="text-text-100 mt-2 -mb-1 text-base font-bold">Macrotask в Event Loop</h3>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]"><code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Macrotask</code> (или просто task) — это единица работы в цикле событий JavaScript. Примеры macrotask: выполнение скрипта, обработка события, callback функции <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">setTimeout()</code>, <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">setInterval()</code>, обработка HTTP-запроса в Node.js. Каждый macrotask выполняется полностью до конца, затем Event Loop переходит к следующему. Важно понимать, что «зависший» на 30 секунд запрос в Node.js не блокирует Event Loop — он просто ждёт своего времени завершения через <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">setTimeout()</code>, а Event Loop продолжает обрабатывать другие задачи.</p>
<h3 class="text-text-100 mt-2 -mb-1 text-base font-bold">Сравнение PHP и Node.js: блокирующая vs неблокирующая модель</h3>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">В PHP каждый HTTP-запрос обрабатывается отдельным процессом или потоком. Если код выполняется долго (например, ожидает базу данных или зависает на 30 секунд), этот процесс/поток блокируется и не может обрабатывать другие запросы. Для обработки многих запросов нужно создавать множество процессов, что потребляет много памяти.</p>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">В Node.js один процесс обрабатывает все запросы через Event Loop. Когда запрос «зависает» (ожидает данные, таймаут), Node.js просто регистрирует callback и переходит к обработке других запросов. Когда событие происходит (пришли данные, истёк таймаут), callback добавляется в очередь задач. Это позволяет Node.js эффективно обрабатывать тысячи одновременных «зависших» соединений с минимальным потреблением ресурсов.</p>
<h3 class="text-text-100 mt-2 -mb-1 text-base font-bold">Объекты Request и Response в Node.js</h3>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">При обработке HTTP-запроса в Node.js создаются два ключевых объекта:</p>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]"><strong><code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">request</code> (http.IncomingMessage)</strong> — содержит информацию о входящем запросе: метод (GET, POST), URL, заголовки, тело запроса.</p>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]"><strong><code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">response</code> (http.ServerResponse)</strong> — используется для отправки ответа клиенту: установка статуса, заголовков, отправка данных.</p>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">Важная особенность: объект <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">response</code> остаётся активным до вызова метода <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">.end()</code>. Это позволяет держать соединение открытым сколько угодно долго, что и используется в <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Long Polling</code>.</p>
<h3 class="text-text-100 mt-2 -mb-1 text-base font-bold">Метод response.end()</h3>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]"><code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">response.end()</code> — метод объекта ServerResponse, который завершает HTTP-ответ и отправляет все данные клиенту. После вызова <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">.end()</code> в этот response больше нельзя ничего записать. Метод может принимать данные для отправки: <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">response.end('данные')</code> или <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">response.end(JSON.stringify(data))</code>. До вызова <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">.end()</code> соединение остаётся открытым, что критично для реализации <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Long Polling</code> — мы намеренно откладываем вызов <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">.end()</code> до появления новых данных или истечения таймаута.</p>
<h3 class="text-text-100 mt-2 -mb-1 text-base font-bold">EventEmitter — событийная система</h3>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]"><code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">EventEmitter</code> — встроенный класс Node.js для реализации паттерна «наблюдатель» (Observer). Позволяет создавать объекты, которые могут генерировать события и подписываться на них:</p>
<div class="relative group/copy bg-bg-000/50 border-0.5 border-border-400 rounded-lg"><div class="sticky opacity-0 group-hover/copy:opacity-100 top-2 py-2 h-12 w-0 float-right"><div class="absolute right-0 h-8 px-2 items-center inline-flex z-10"><button class="inline-flex
  items-center
  justify-center
  relative
  shrink-0
  can-focus
  select-none
  disabled:pointer-events-none
  disabled:opacity-50
  disabled:shadow-none
  disabled:drop-shadow-none border-transparent
          transition
          font-base
          duration-300
          ease-[cubic-bezier(0.165,0.85,0.45,1)] h-8 w-8 rounded-md active:scale-95 backdrop-blur-md Button_ghost__BUAoh" type="button" aria-label="Copy to clipboard" data-state="closed"><div class="relative"><div class="flex items-center justify-center transition-all opacity-100 scale-100" style="width: 20px; height: 20px;"><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg" class="shrink-0 transition-all opacity-100 scale-100" aria-hidden="true"><path d="M12.5 3C13.3284 3 14 3.67157 14 4.5V6H15.5C16.3284 6 17 6.67157 17 7.5V15.5C17 16.3284 16.3284 17 15.5 17H7.5C6.67157 17 6 16.3284 6 15.5V14H4.5C3.67157 14 3 13.3284 3 12.5V4.5C3 3.67157 3.67157 3 4.5 3H12.5ZM14 12.5C14 13.3284 13.3284 14 12.5 14H7V15.5C7 15.7761 7.22386 16 7.5 16H15.5C15.7761 16 16 15.7761 16 15.5V7.5C16 7.22386 15.7761 7 15.5 7H14V12.5ZM4.5 4C4.22386 4 4 4.22386 4 4.5V12.5C4 12.7761 4.22386 13 4.5 13H12.5C12.7761 13 13 12.7761 13 12.5V4.5C13 4.22386 12.7761 4 12.5 4H4.5Z"></path></svg></div><div class="flex items-center justify-center absolute top-0 left-0 transition-all opacity-0 scale-50" style="width: 20px; height: 20px;"><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg" class="shrink-0 absolute top-0 left-0 transition-all opacity-0 scale-50" aria-hidden="true"><path d="M15.1883 5.10908C15.3699 4.96398 15.6346 4.96153 15.8202 5.11592C16.0056 5.27067 16.0504 5.53125 15.9403 5.73605L15.8836 5.82003L8.38354 14.8202C8.29361 14.9279 8.16242 14.9925 8.02221 14.9989C7.88203 15.0051 7.74545 14.9526 7.64622 14.8534L4.14617 11.3533L4.08172 11.2752C3.95384 11.0811 3.97542 10.817 4.14617 10.6463C4.31693 10.4755 4.58105 10.4539 4.77509 10.5818L4.85321 10.6463L7.96556 13.7586L15.1161 5.1794L15.1883 5.10908Z"></path></svg></div></div></button></div></div><div class="text-text-500 font-small p-3.5 pb-0">javascript</div><div><pre class="code-block__code !my-0 !rounded-lg !text-sm !leading-relaxed" style="background: transparent; color: rgb(171, 178, 191); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; font-family: var(--font-mono); direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border-radius: 0.3em;"><code class="language-javascript" style="background: transparent; color: rgb(171, 178, 191); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; font-family: var(--font-mono); direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none;"><span><span class="token" style="color: rgb(198, 120, 221);">const</span><span> </span><span class="token maybe-class-name">EventEmitter</span><span> </span><span class="token" style="color: rgb(97, 175, 239);">=</span><span> </span><span class="token" style="color: rgb(97, 175, 239);">require</span><span class="token" style="color: rgb(171, 178, 191);">(</span><span class="token" style="color: rgb(152, 195, 121);">'events'</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span class="token" style="color: rgb(171, 178, 191);">;</span><span>
</span></span><span><span></span><span class="token" style="color: rgb(198, 120, 221);">const</span><span> emitter </span><span class="token" style="color: rgb(97, 175, 239);">=</span><span> </span><span class="token" style="color: rgb(198, 120, 221);">new</span><span> </span><span class="token" style="color: rgb(209, 154, 102);">EventEmitter</span><span class="token" style="color: rgb(171, 178, 191);">(</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span class="token" style="color: rgb(171, 178, 191);">;</span><span>
</span></span><span>
</span><span><span></span><span class="token" style="color: rgb(92, 99, 112); font-style: italic;">// Подписка на событие</span><span>
</span></span><span><span>emitter</span><span class="token" style="color: rgb(171, 178, 191);">.</span><span class="token method property-access" style="color: rgb(97, 175, 239);">on</span><span class="token" style="color: rgb(171, 178, 191);">(</span><span class="token" style="color: rgb(152, 195, 121);">'newItem'</span><span class="token" style="color: rgb(171, 178, 191);">,</span><span> </span><span class="token" style="color: rgb(171, 178, 191);">(</span><span class="token parameter">item</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span> </span><span class="token arrow" style="color: rgb(97, 175, 239);">=&gt;</span><span> </span><span class="token" style="color: rgb(171, 178, 191);">{</span><span>
</span></span><span><span>  </span><span class="token console" style="color: rgb(209, 154, 102);">console</span><span class="token" style="color: rgb(171, 178, 191);">.</span><span class="token method property-access" style="color: rgb(97, 175, 239);">log</span><span class="token" style="color: rgb(171, 178, 191);">(</span><span class="token" style="color: rgb(152, 195, 121);">'Новый элемент:'</span><span class="token" style="color: rgb(171, 178, 191);">,</span><span> item</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span class="token" style="color: rgb(171, 178, 191);">;</span><span>
</span></span><span><span></span><span class="token" style="color: rgb(171, 178, 191);">}</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span class="token" style="color: rgb(171, 178, 191);">;</span><span>
</span></span><span>
</span><span><span></span><span class="token" style="color: rgb(92, 99, 112); font-style: italic;">// Генерация события</span><span>
</span></span><span><span>emitter</span><span class="token" style="color: rgb(171, 178, 191);">.</span><span class="token method property-access" style="color: rgb(97, 175, 239);">emit</span><span class="token" style="color: rgb(171, 178, 191);">(</span><span class="token" style="color: rgb(152, 195, 121);">'newItem'</span><span class="token" style="color: rgb(171, 178, 191);">,</span><span> </span><span class="token" style="color: rgb(171, 178, 191);">{</span><span> </span><span class="token literal-property" style="color: rgb(224, 108, 117);">id</span><span class="token" style="color: rgb(97, 175, 239);">:</span><span> </span><span class="token" style="color: rgb(209, 154, 102);">1</span><span class="token" style="color: rgb(171, 178, 191);">,</span><span> </span><span class="token literal-property" style="color: rgb(224, 108, 117);">data</span><span class="token" style="color: rgb(97, 175, 239);">:</span><span> </span><span class="token" style="color: rgb(152, 195, 121);">'test'</span><span> </span><span class="token" style="color: rgb(171, 178, 191);">}</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span class="token" style="color: rgb(171, 178, 191);">;</span></span></code></pre></div></div>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">Для домашнего задания можно создать <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">EventEmitter</code>, который генерирует событие <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">'newItem'</code> при вызове <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">addItem()</code>, а обработчики запросов подписываются на это событие и завершают <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">response</code> при его наступлении.</p>
<h3 class="text-text-100 mt-2 -mb-1 text-base font-bold">JavaScript Proxy для отслеживания изменений</h3>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]"><code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Proxy</code> — объект JavaScript, который перехватывает операции над другим объектом (чтение, запись, удаление свойств). Можно использовать для отслеживания добавления элементов в массив:</p>
<div class="relative group/copy bg-bg-000/50 border-0.5 border-border-400 rounded-lg"><div class="sticky opacity-0 group-hover/copy:opacity-100 top-2 py-2 h-12 w-0 float-right"><div class="absolute right-0 h-8 px-2 items-center inline-flex z-10"><button class="inline-flex
  items-center
  justify-center
  relative
  shrink-0
  can-focus
  select-none
  disabled:pointer-events-none
  disabled:opacity-50
  disabled:shadow-none
  disabled:drop-shadow-none border-transparent
          transition
          font-base
          duration-300
          ease-[cubic-bezier(0.165,0.85,0.45,1)] h-8 w-8 rounded-md active:scale-95 backdrop-blur-md Button_ghost__BUAoh" type="button" aria-label="Copy to clipboard" data-state="closed"><div class="relative"><div class="flex items-center justify-center transition-all opacity-100 scale-100" style="width: 20px; height: 20px;"><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg" class="shrink-0 transition-all opacity-100 scale-100" aria-hidden="true"><path d="M12.5 3C13.3284 3 14 3.67157 14 4.5V6H15.5C16.3284 6 17 6.67157 17 7.5V15.5C17 16.3284 16.3284 17 15.5 17H7.5C6.67157 17 6 16.3284 6 15.5V14H4.5C3.67157 14 3 13.3284 3 12.5V4.5C3 3.67157 3.67157 3 4.5 3H12.5ZM14 12.5C14 13.3284 13.3284 14 12.5 14H7V15.5C7 15.7761 7.22386 16 7.5 16H15.5C15.7761 16 16 15.7761 16 15.5V7.5C16 7.22386 15.7761 7 15.5 7H14V12.5ZM4.5 4C4.22386 4 4 4.22386 4 4.5V12.5C4 12.7761 4.22386 13 4.5 13H12.5C12.7761 13 13 12.7761 13 12.5V4.5C13 4.22386 12.7761 4 12.5 4H4.5Z"></path></svg></div><div class="flex items-center justify-center absolute top-0 left-0 transition-all opacity-0 scale-50" style="width: 20px; height: 20px;"><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg" class="shrink-0 absolute top-0 left-0 transition-all opacity-0 scale-50" aria-hidden="true"><path d="M15.1883 5.10908C15.3699 4.96398 15.6346 4.96153 15.8202 5.11592C16.0056 5.27067 16.0504 5.53125 15.9403 5.73605L15.8836 5.82003L8.38354 14.8202C8.29361 14.9279 8.16242 14.9925 8.02221 14.9989C7.88203 15.0051 7.74545 14.9526 7.64622 14.8534L4.14617 11.3533L4.08172 11.2752C3.95384 11.0811 3.97542 10.817 4.14617 10.6463C4.31693 10.4755 4.58105 10.4539 4.77509 10.5818L4.85321 10.6463L7.96556 13.7586L15.1161 5.1794L15.1883 5.10908Z"></path></svg></div></div></button></div></div><div class="text-text-500 font-small p-3.5 pb-0">javascript</div><div><pre class="code-block__code !my-0 !rounded-lg !text-sm !leading-relaxed" style="background: transparent; color: rgb(171, 178, 191); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; font-family: var(--font-mono); direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border-radius: 0.3em;"><code class="language-javascript" style="background: transparent; color: rgb(171, 178, 191); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; font-family: var(--font-mono); direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none;"><span><span class="token" style="color: rgb(198, 120, 221);">const</span><span> items </span><span class="token" style="color: rgb(97, 175, 239);">=</span><span> </span><span class="token" style="color: rgb(171, 178, 191);">[</span><span class="token" style="color: rgb(171, 178, 191);">]</span><span class="token" style="color: rgb(171, 178, 191);">;</span><span>
</span></span><span><span></span><span class="token" style="color: rgb(198, 120, 221);">const</span><span> itemsProxy </span><span class="token" style="color: rgb(97, 175, 239);">=</span><span> </span><span class="token" style="color: rgb(198, 120, 221);">new</span><span> </span><span class="token" style="color: rgb(209, 154, 102);">Proxy</span><span class="token" style="color: rgb(171, 178, 191);">(</span><span>items</span><span class="token" style="color: rgb(171, 178, 191);">,</span><span> </span><span class="token" style="color: rgb(171, 178, 191);">{</span><span>
</span></span><span><span>  </span><span class="token" style="color: rgb(97, 175, 239);">set</span><span class="token" style="color: rgb(171, 178, 191);">(</span><span>target</span><span class="token" style="color: rgb(171, 178, 191);">,</span><span> property</span><span class="token" style="color: rgb(171, 178, 191);">,</span><span> value</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span> </span><span class="token" style="color: rgb(171, 178, 191);">{</span><span>
</span></span><span><span>    target</span><span class="token" style="color: rgb(171, 178, 191);">[</span><span>property</span><span class="token" style="color: rgb(171, 178, 191);">]</span><span> </span><span class="token" style="color: rgb(97, 175, 239);">=</span><span> value</span><span class="token" style="color: rgb(171, 178, 191);">;</span><span>
</span></span><span><span>    </span><span class="token control-flow" style="color: rgb(198, 120, 221);">if</span><span> </span><span class="token" style="color: rgb(171, 178, 191);">(</span><span>property </span><span class="token" style="color: rgb(97, 175, 239);">!==</span><span> </span><span class="token" style="color: rgb(152, 195, 121);">'length'</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span> </span><span class="token" style="color: rgb(171, 178, 191);">{</span><span>
</span></span><span><span>      </span><span class="token" style="color: rgb(92, 99, 112); font-style: italic;">// Вызвать функцию уведомления клиентов</span><span>
</span></span><span><span>      </span><span class="token" style="color: rgb(97, 175, 239);">notifyClients</span><span class="token" style="color: rgb(171, 178, 191);">(</span><span>value</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span class="token" style="color: rgb(171, 178, 191);">;</span><span>
</span></span><span><span>    </span><span class="token" style="color: rgb(171, 178, 191);">}</span><span>
</span></span><span><span>    </span><span class="token control-flow" style="color: rgb(198, 120, 221);">return</span><span> </span><span class="token" style="color: rgb(209, 154, 102);">true</span><span class="token" style="color: rgb(171, 178, 191);">;</span><span>
</span></span><span><span>  </span><span class="token" style="color: rgb(171, 178, 191);">}</span><span>
</span></span><span><span></span><span class="token" style="color: rgb(171, 178, 191);">}</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span class="token" style="color: rgb(171, 178, 191);">;</span><span>
</span></span><span>
</span><span><span>itemsProxy</span><span class="token" style="color: rgb(171, 178, 191);">.</span><span class="token method property-access" style="color: rgb(97, 175, 239);">push</span><span class="token" style="color: rgb(171, 178, 191);">(</span><span>newItem</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span class="token" style="color: rgb(171, 178, 191);">;</span><span> </span><span class="token" style="color: rgb(92, 99, 112); font-style: italic;">// Перехватится и вызовет notifyClients</span></span></code></pre></div></div>
<h3 class="text-text-100 mt-2 -mb-1 text-base font-bold">Паттерн массива активных клиентов</h3>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">В профессиональных реализациях <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Long Polling</code> обычно используют массив (или Set) для хранения всех активных подключений:</p>
<div class="relative group/copy bg-bg-000/50 border-0.5 border-border-400 rounded-lg"><div class="sticky opacity-0 group-hover/copy:opacity-100 top-2 py-2 h-12 w-0 float-right"><div class="absolute right-0 h-8 px-2 items-center inline-flex z-10"><button class="inline-flex
  items-center
  justify-center
  relative
  shrink-0
  can-focus
  select-none
  disabled:pointer-events-none
  disabled:opacity-50
  disabled:shadow-none
  disabled:drop-shadow-none border-transparent
          transition
          font-base
          duration-300
          ease-[cubic-bezier(0.165,0.85,0.45,1)] h-8 w-8 rounded-md active:scale-95 backdrop-blur-md Button_ghost__BUAoh" type="button" aria-label="Copy to clipboard" data-state="closed"><div class="relative"><div class="flex items-center justify-center transition-all opacity-100 scale-100" style="width: 20px; height: 20px;"><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg" class="shrink-0 transition-all opacity-100 scale-100" aria-hidden="true"><path d="M12.5 3C13.3284 3 14 3.67157 14 4.5V6H15.5C16.3284 6 17 6.67157 17 7.5V15.5C17 16.3284 16.3284 17 15.5 17H7.5C6.67157 17 6 16.3284 6 15.5V14H4.5C3.67157 14 3 13.3284 3 12.5V4.5C3 3.67157 3.67157 3 4.5 3H12.5ZM14 12.5C14 13.3284 13.3284 14 12.5 14H7V15.5C7 15.7761 7.22386 16 7.5 16H15.5C15.7761 16 16 15.7761 16 15.5V7.5C16 7.22386 15.7761 7 15.5 7H14V12.5ZM4.5 4C4.22386 4 4 4.22386 4 4.5V12.5C4 12.7761 4.22386 13 4.5 13H12.5C12.7761 13 13 12.7761 13 12.5V4.5C13 4.22386 12.7761 4 12.5 4H4.5Z"></path></svg></div><div class="flex items-center justify-center absolute top-0 left-0 transition-all opacity-0 scale-50" style="width: 20px; height: 20px;"><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg" class="shrink-0 absolute top-0 left-0 transition-all opacity-0 scale-50" aria-hidden="true"><path d="M15.1883 5.10908C15.3699 4.96398 15.6346 4.96153 15.8202 5.11592C16.0056 5.27067 16.0504 5.53125 15.9403 5.73605L15.8836 5.82003L8.38354 14.8202C8.29361 14.9279 8.16242 14.9925 8.02221 14.9989C7.88203 15.0051 7.74545 14.9526 7.64622 14.8534L4.14617 11.3533L4.08172 11.2752C3.95384 11.0811 3.97542 10.817 4.14617 10.6463C4.31693 10.4755 4.58105 10.4539 4.77509 10.5818L4.85321 10.6463L7.96556 13.7586L15.1161 5.1794L15.1883 5.10908Z"></path></svg></div></div></button></div></div><div class="text-text-500 font-small p-3.5 pb-0">javascript</div><div><pre class="code-block__code !my-0 !rounded-lg !text-sm !leading-relaxed" style="background: transparent; color: rgb(171, 178, 191); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; font-family: var(--font-mono); direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border-radius: 0.3em;"><code class="language-javascript" style="background: transparent; color: rgb(171, 178, 191); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; font-family: var(--font-mono); direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none;"><span><span class="token" style="color: rgb(198, 120, 221);">const</span><span> activeClients </span><span class="token" style="color: rgb(97, 175, 239);">=</span><span> </span><span class="token" style="color: rgb(171, 178, 191);">[</span><span class="token" style="color: rgb(171, 178, 191);">]</span><span class="token" style="color: rgb(171, 178, 191);">;</span><span>
</span></span><span>
</span><span><span></span><span class="token" style="color: rgb(92, 99, 112); font-style: italic;">// При новом запросе</span><span>
</span></span><span><span>activeClients</span><span class="token" style="color: rgb(171, 178, 191);">.</span><span class="token method property-access" style="color: rgb(97, 175, 239);">push</span><span class="token" style="color: rgb(171, 178, 191);">(</span><span>response</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span class="token" style="color: rgb(171, 178, 191);">;</span><span>
</span></span><span>
</span><span><span></span><span class="token" style="color: rgb(92, 99, 112); font-style: italic;">// При добавлении элемента</span><span>
</span></span><span><span></span><span class="token" style="color: rgb(198, 120, 221);">function</span><span> </span><span class="token" style="color: rgb(97, 175, 239);">addItem</span><span class="token" style="color: rgb(171, 178, 191);">(</span><span class="token parameter">item</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span> </span><span class="token" style="color: rgb(171, 178, 191);">{</span><span>
</span></span><span><span>  activeClients</span><span class="token" style="color: rgb(171, 178, 191);">.</span><span class="token method property-access" style="color: rgb(97, 175, 239);">forEach</span><span class="token" style="color: rgb(171, 178, 191);">(</span><span class="token parameter">response</span><span> </span><span class="token arrow" style="color: rgb(97, 175, 239);">=&gt;</span><span> </span><span class="token" style="color: rgb(171, 178, 191);">{</span><span>
</span></span><span><span>    response</span><span class="token" style="color: rgb(171, 178, 191);">.</span><span class="token method property-access" style="color: rgb(97, 175, 239);">end</span><span class="token" style="color: rgb(171, 178, 191);">(</span><span class="token known-class-name" style="color: rgb(209, 154, 102);">JSON</span><span class="token" style="color: rgb(171, 178, 191);">.</span><span class="token method property-access" style="color: rgb(97, 175, 239);">stringify</span><span class="token" style="color: rgb(171, 178, 191);">(</span><span>item</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span class="token" style="color: rgb(171, 178, 191);">;</span><span>
</span></span><span><span>  </span><span class="token" style="color: rgb(171, 178, 191);">}</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span class="token" style="color: rgb(171, 178, 191);">;</span><span>
</span></span><span><span>  activeClients</span><span class="token" style="color: rgb(171, 178, 191);">.</span><span class="token property-access">length</span><span> </span><span class="token" style="color: rgb(97, 175, 239);">=</span><span> </span><span class="token" style="color: rgb(209, 154, 102);">0</span><span class="token" style="color: rgb(171, 178, 191);">;</span><span> </span><span class="token" style="color: rgb(92, 99, 112); font-style: italic;">// Очистка массива</span><span>
</span></span><span><span></span><span class="token" style="color: rgb(171, 178, 191);">}</span></span></code></pre></div></div>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">Этот подход масштабируется и позволяет легко управлять множеством одновременных подключений.</p>
<h3 class="text-text-100 mt-2 -mb-1 text-base font-bold">Реализация таймаута с setTimeout()</h3>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">Для ограничения времени ожидания запроса используется <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">setTimeout()</code>:</p>
<div class="relative group/copy bg-bg-000/50 border-0.5 border-border-400 rounded-lg"><div class="sticky opacity-0 group-hover/copy:opacity-100 top-2 py-2 h-12 w-0 float-right"><div class="absolute right-0 h-8 px-2 items-center inline-flex z-10"><button class="inline-flex
  items-center
  justify-center
  relative
  shrink-0
  can-focus
  select-none
  disabled:pointer-events-none
  disabled:opacity-50
  disabled:shadow-none
  disabled:drop-shadow-none border-transparent
          transition
          font-base
          duration-300
          ease-[cubic-bezier(0.165,0.85,0.45,1)] h-8 w-8 rounded-md active:scale-95 backdrop-blur-md Button_ghost__BUAoh" type="button" aria-label="Copy to clipboard" data-state="closed"><div class="relative"><div class="flex items-center justify-center transition-all opacity-100 scale-100" style="width: 20px; height: 20px;"><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg" class="shrink-0 transition-all opacity-100 scale-100" aria-hidden="true"><path d="M12.5 3C13.3284 3 14 3.67157 14 4.5V6H15.5C16.3284 6 17 6.67157 17 7.5V15.5C17 16.3284 16.3284 17 15.5 17H7.5C6.67157 17 6 16.3284 6 15.5V14H4.5C3.67157 14 3 13.3284 3 12.5V4.5C3 3.67157 3.67157 3 4.5 3H12.5ZM14 12.5C14 13.3284 13.3284 14 12.5 14H7V15.5C7 15.7761 7.22386 16 7.5 16H15.5C15.7761 16 16 15.7761 16 15.5V7.5C16 7.22386 15.7761 7 15.5 7H14V12.5ZM4.5 4C4.22386 4 4 4.22386 4 4.5V12.5C4 12.7761 4.22386 13 4.5 13H12.5C12.7761 13 13 12.7761 13 12.5V4.5C13 4.22386 12.7761 4 12.5 4H4.5Z"></path></svg></div><div class="flex items-center justify-center absolute top-0 left-0 transition-all opacity-0 scale-50" style="width: 20px; height: 20px;"><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg" class="shrink-0 absolute top-0 left-0 transition-all opacity-0 scale-50" aria-hidden="true"><path d="M15.1883 5.10908C15.3699 4.96398 15.6346 4.96153 15.8202 5.11592C16.0056 5.27067 16.0504 5.53125 15.9403 5.73605L15.8836 5.82003L8.38354 14.8202C8.29361 14.9279 8.16242 14.9925 8.02221 14.9989C7.88203 15.0051 7.74545 14.9526 7.64622 14.8534L4.14617 11.3533L4.08172 11.2752C3.95384 11.0811 3.97542 10.817 4.14617 10.6463C4.31693 10.4755 4.58105 10.4539 4.77509 10.5818L4.85321 10.6463L7.96556 13.7586L15.1161 5.1794L15.1883 5.10908Z"></path></svg></div></div></button></div></div><div class="text-text-500 font-small p-3.5 pb-0">javascript</div><div><pre class="code-block__code !my-0 !rounded-lg !text-sm !leading-relaxed" style="background: transparent; color: rgb(171, 178, 191); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; font-family: var(--font-mono); direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border-radius: 0.3em;"><code class="language-javascript" style="background: transparent; color: rgb(171, 178, 191); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; font-family: var(--font-mono); direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none;"><span><span class="token" style="color: rgb(198, 120, 221);">const</span><span> timeout </span><span class="token" style="color: rgb(97, 175, 239);">=</span><span> </span><span class="token" style="color: rgb(97, 175, 239);">setTimeout</span><span class="token" style="color: rgb(171, 178, 191);">(</span><span class="token" style="color: rgb(171, 178, 191);">(</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span> </span><span class="token arrow" style="color: rgb(97, 175, 239);">=&gt;</span><span> </span><span class="token" style="color: rgb(171, 178, 191);">{</span><span>
</span></span><span><span>  response</span><span class="token" style="color: rgb(171, 178, 191);">.</span><span class="token method property-access" style="color: rgb(97, 175, 239);">end</span><span class="token" style="color: rgb(171, 178, 191);">(</span><span class="token known-class-name" style="color: rgb(209, 154, 102);">JSON</span><span class="token" style="color: rgb(171, 178, 191);">.</span><span class="token method property-access" style="color: rgb(97, 175, 239);">stringify</span><span class="token" style="color: rgb(171, 178, 191);">(</span><span class="token nil" style="color: rgb(198, 120, 221);">null</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span class="token" style="color: rgb(171, 178, 191);">;</span><span>
</span></span><span><span>  </span><span class="token" style="color: rgb(92, 99, 112); font-style: italic;">// Удалить response из массива активных клиентов</span><span>
</span></span><span><span></span><span class="token" style="color: rgb(171, 178, 191);">}</span><span class="token" style="color: rgb(171, 178, 191);">,</span><span> </span><span class="token" style="color: rgb(209, 154, 102);">30000</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span class="token" style="color: rgb(171, 178, 191);">;</span><span> </span><span class="token" style="color: rgb(92, 99, 112); font-style: italic;">// 30 секунд</span><span>
</span></span><span>
</span><span><span></span><span class="token" style="color: rgb(92, 99, 112); font-style: italic;">// При получении новых данных до истечения таймаута</span><span>
</span></span><span><span></span><span class="token" style="color: rgb(97, 175, 239);">clearTimeout</span><span class="token" style="color: rgb(171, 178, 191);">(</span><span>timeout</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span class="token" style="color: rgb(171, 178, 191);">;</span><span> </span><span class="token" style="color: rgb(92, 99, 112); font-style: italic;">// Отменить таймаут</span><span>
</span></span><span><span>response</span><span class="token" style="color: rgb(171, 178, 191);">.</span><span class="token method property-access" style="color: rgb(97, 175, 239);">end</span><span class="token" style="color: rgb(171, 178, 191);">(</span><span class="token known-class-name" style="color: rgb(209, 154, 102);">JSON</span><span class="token" style="color: rgb(171, 178, 191);">.</span><span class="token method property-access" style="color: rgb(97, 175, 239);">stringify</span><span class="token" style="color: rgb(171, 178, 191);">(</span><span>newItem</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span class="token" style="color: rgb(171, 178, 191);">)</span><span class="token" style="color: rgb(171, 178, 191);">;</span></span></code></pre></div></div>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">Важно не забывать очищать таймаут с помощью <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">clearTimeout()</code>, если данные пришли раньше, чтобы избежать утечек памяти и двойной отправки ответа.</p>
<h3 class="text-text-100 mt-2 -mb-1 text-base font-bold">Исторический пример: ВКонтакте и Long Polling</h3>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">В начале 2010-х годов ВКонтакте использовал <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">XHR Long Polling</code> для реализации обмена мгновенными сообщениями. При открытии диалога браузер отправлял запрос на специальный эндпоинт, который висел до получения нового сообщения или истечения таймаута (~90 секунд). Это позволяло получать сообщения практически мгновенно без постоянной нагрузки на сервер. После появления поддержки <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">WebSocket</code> в браузерах, система стала использовать сокеты, но сохранила <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">Long Polling</code> как fallback-механизм для старых браузеров. Эта практика показывает важность постепенной миграции и поддержки обратной совместимости в крупных приложениях.</p>
<h3 class="text-text-100 mt-2 -mb-1 text-base font-bold">Тестирование без клиентского кода</h3>
<p class="font-claude-response-body break-words whitespace-normal leading-[1.7]">Для тестирования домашнего задания не нужно писать JavaScript-код на стороне клиента. Достаточно просто открыть URL в браузере (например, <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">http://localhost:3000</code>). Браузер отправит GET-запрос, и вы увидите либо данные нового элемента (если он был добавлен за время ожидания), либо <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">null</code> (если таймаут истёк). Для повторного теста просто обновите страницу. В браузерной консоли (вкладка Network) можно наблюдать, как долго висит запрос перед получением ответа.</p></div></div>
</template>

<script setup>
import screenshot_0002 from '@/assets/xxx/screenshot_0002.jpg';
import screenshot_0055 from '@/assets/xxx/screenshot_0055.jpg';
import screenshot_0127 from '@/assets/xxx/screenshot_0127.jpg';
import screenshot_0129 from '@/assets/xxx/screenshot_0129.jpg';
import screenshot_0146 from '@/assets/xxx/screenshot_0146.jpg';
import screenshot_0150 from '@/assets/xxx/screenshot_0150.jpg';
import screenshot_0155 from '@/assets/xxx/screenshot_0155.jpg';
import screenshot_0242 from '@/assets/xxx/screenshot_0242.jpg';
import screenshot_0411 from '@/assets/xxx/screenshot_0411.jpg';
import screenshot_0413 from '@/assets/xxx/screenshot_0413.jpg';
import screenshot_0535 from '@/assets/xxx/screenshot_0535.jpg';
import screenshot_0537 from '@/assets/xxx/screenshot_0537.jpg';
</script>
